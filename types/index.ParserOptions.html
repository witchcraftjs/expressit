<!DOCTYPE html><html class="default" lang="en"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>ParserOptions | @witchcraft/expressit</title><meta name="description" content="Documentation for @witchcraft/expressit"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search" data-base=".."><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"><a href="https://github.com/witchcraftjs/expressit">Github</a><a href="https://github.com/witchcraftjs/expressit/issues">Issues</a><a href="http://npmjs.com/@witchcraft/expressit">npm</a></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">@witchcraft/expressit</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../index.html">@witchcraft/expressit</a></li><li><a href="../modules/index.html">index</a></li><li><a href="index.ParserOptions.html">ParserOptions</a></li></ul><h1>Type Alias ParserOptions&lt;T&gt;</h1></div><div class="tsd-signature"><span class="tsd-kind-type-alias">Parser<wbr/>Options</span><span class="tsd-signature-symbol">&lt;</span><a class="tsd-signature-type tsd-kind-type-parameter" href="index.ParserOptions.html#T">T</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">:</span> <span class="tsd-signature-symbol">{ </span><br/><span>    </span><span class="tsd-kind-property">arrayValues</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">property</span>, <span class="tsd-kind-parameter">operator</span>, <span class="tsd-kind-parameter">isExpanded</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">conditionNormalizer</span><span class="tsd-signature-symbol">?: </span><a href="index.ConditionNormalizer.html" class="tsd-signature-type tsd-kind-type-alias">ConditionNormalizer</a><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">customPropertyOperators</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">expandedPropertySeparator</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">keyParser</span><span class="tsd-signature-symbol">?: </span><a href="index.KeyParser.html" class="tsd-signature-type tsd-kind-type-alias">KeyParser</a><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">keywords</span><span class="tsd-signature-symbol">?: </span><a href="index.KeywordOptions.html" class="tsd-signature-type tsd-kind-type-alias">KeywordOptions</a><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">onMissingBooleanOperator</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">&quot;error&quot;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">&quot;and&quot;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">&quot;or&quot;</span><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">prefixApplier</span><span class="tsd-signature-symbol">?: </span><a href="index.PrefixApplier.html" class="tsd-signature-type tsd-kind-type-alias">PrefixApplier</a><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">prefixableGroups</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">prefixableStrings</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">regexValues</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">property</span>, <span class="tsd-kind-parameter">operator</span>, <span class="tsd-kind-parameter">isExpanded</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">valueComparer</span><span class="tsd-signature-symbol">?: </span><a href="index.ValueComparer.html" class="tsd-signature-type tsd-kind-type-alias">ValueComparer</a><span class="tsd-signature-symbol">; </span><br/><span>    </span><span class="tsd-kind-property">valueValidator</span><span class="tsd-signature-symbol">?: </span><a href="index.ValueValidator.html" class="tsd-signature-type tsd-kind-type-alias">ValueValidator</a><span class="tsd-signature-symbol">&lt;</span><a class="tsd-signature-type tsd-kind-type-parameter" href="index.ParserOptions.html#T">T</a><span class="tsd-signature-symbol">&gt;</span><span class="tsd-signature-symbol">; </span><br/><span class="tsd-signature-symbol">}</span></div><section class="tsd-panel"><h4>Type Parameters</h4><ul class="tsd-type-parameter-list"><li><span><a id="T" class="tsd-anchor"></a><span class="tsd-kind-type-parameter">T</span><span class="tsd-signature-keyword"> extends </span><span class="tsd-signature-symbol">{}</span> = <span class="tsd-signature-symbol">{}</span></span></li></ul></section><div class="tsd-type-declaration"><h4>Type declaration</h4><ul class="tsd-parameters"><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">array<wbr/>Values</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">property</span>, <span class="tsd-kind-parameter">operator</span>, <span class="tsd-kind-parameter">isExpanded</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">)</span></h5><div class="tsd-comment tsd-typography"><p>Enables array values, both alone, and for any property operators.</p>
<p>Values need not be separated by anything except spaces and values inside follow the same rules as for any lone variables. They can be quoted and prefixed (if prefixableStrings is enabled). They cannot be regex values.</p>
<p>Any operators, etc, are treated as values.</p>
<p>While missing right parens can be detected, missing left ones cannot. Input like <code>a &amp;&amp; val]</code> is interpreted as <code>&quot;a&quot; &amp;&amp; &quot;val]&quot;</code>.</p>
</div><div class="tsd-comment tsd-typography"></div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">condition<wbr/>Normalizer</span><span class="tsd-signature-symbol">?: </span><a href="index.ConditionNormalizer.html" class="tsd-signature-type tsd-kind-type-alias">ConditionNormalizer</a></h5><div class="tsd-comment tsd-typography"><p>When <a href="../classes/index.Parser.html#normalize">normalizing</a> an ast, this function is needed to determine what exactly the value and operator of the condition is and whether it should be negated when evaluating.</p>
<p>Given a query object it should return the values of the <code>value</code>, <code>operator</code>, and <code>negate</code> properties that will be assigned to <a href="../classes/index.ast.Condition.html">Condition</a>.</p>
<p>You can think of the query object as a simplified version of the condition node. See <a href="index.ValueQuery.html">ValueQuery</a> for details on each property.</p>
<p>A default function is available, but it just sets the value to the query value, ignoring everything else.</p>
<p>Example of how you might approach writing a function that handles all the different parser features (groups, prefixed strings, etc):</p>
<pre><code class="ts"><span class="hl-5">type</span><span class="hl-1"> </span><span class="hl-9">RawOperators</span><span class="hl-1"> = </span><span class="hl-4">&quot;&gt;&quot;</span><span class="hl-1"> | </span><span class="hl-4">&quot;contains&quot;</span><span class="hl-1"> | </span><span class="hl-2">// operator types (expanded vs custom) are not distinguished from each other</span><br/><span class="hl-5">type</span><span class="hl-1"> </span><span class="hl-9">RawPrefixes</span><span class="hl-1"> = </span><span class="hl-4">&quot;num&quot;</span><br/><span class="hl-5">type</span><span class="hl-1"> </span><span class="hl-9">Operators</span><span class="hl-1"> = </span><span class="hl-4">&quot;contains&quot;</span><br/><br/><span class="hl-5">function</span><span class="hl-1"> </span><span class="hl-7">conditionNormalizer</span><span class="hl-1">({ </span><span class="hl-0">operator</span><span class="hl-1">, </span><span class="hl-0">prefix</span><span class="hl-1">, </span><span class="hl-0">value</span><span class="hl-1">, </span><span class="hl-0">regexFlags</span><span class="hl-1">, </span><span class="hl-0">isRegex</span><span class="hl-1">, </span><span class="hl-0">isExpanded</span><span class="hl-1">, </span><span class="hl-0">isNegated</span><span class="hl-1">, </span><span class="hl-0">isQuoted</span><span class="hl-1"> }: </span><span class="hl-9">ValueQuery</span><span class="hl-1">): {</span><span class="hl-0">value</span><span class="hl-1">:</span><span class="hl-9">any</span><span class="hl-1">, </span><span class="hl-0">operator</span><span class="hl-1">: </span><span class="hl-9">Operators</span><span class="hl-1">} {</span><br/><span class="hl-1">	</span><span class="hl-5">let</span><span class="hl-1"> </span><span class="hl-0">finalValue</span><span class="hl-1">: </span><span class="hl-9">any</span><span class="hl-1"> = </span><span class="hl-0">value</span><br/><span class="hl-1">	</span><span class="hl-5">let</span><span class="hl-1"> </span><span class="hl-0">finalOperator</span><span class="hl-1">: </span><span class="hl-9">any</span><span class="hl-1"> = </span><span class="hl-0">operator</span><br/><span class="hl-1">	</span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-0">prefix</span><span class="hl-1">) {</span><br/><span class="hl-1">		</span><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-6">val</span><span class="hl-1"> = </span><span class="hl-0">value</span><span class="hl-1"> </span><span class="hl-3">as</span><span class="hl-1"> </span><span class="hl-9">string</span><span class="hl-1"> </span><span class="hl-2">// it&#39;s always a string if prefixed</span><br/><span class="hl-1">		</span><span class="hl-3">switch</span><span class="hl-1"> (</span><span class="hl-0">prefix</span><span class="hl-1"> </span><span class="hl-3">as</span><span class="hl-1"> </span><span class="hl-9">RawPrefixes</span><span class="hl-1">) {</span><br/><span class="hl-1">			</span><span class="hl-3">case</span><span class="hl-1"> </span><span class="hl-4">&quot;num&quot;</span><span class="hl-1">: </span><span class="hl-0">finalValue</span><span class="hl-1"> = </span><span class="hl-7">parseInt</span><span class="hl-1">(</span><span class="hl-0">val</span><span class="hl-1">, </span><span class="hl-8">2</span><span class="hl-1">); </span><span class="hl-3">break</span><br/><span class="hl-1">			</span><span class="hl-2">// ...</span><br/><span class="hl-1">		}</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">	</span><span class="hl-2">// another way to allow special unquoted value types is something like this:</span><br/><span class="hl-1">	</span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-5">typeof</span><span class="hl-1"> </span><span class="hl-0">value</span><span class="hl-1"> === </span><span class="hl-4">&quot;string&quot;</span><span class="hl-1"> &amp;&amp; !</span><span class="hl-0">isQuoted</span><span class="hl-1">) {</span><br/><span class="hl-1">		</span><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-6">asNum</span><span class="hl-1"> = </span><span class="hl-7">parseInt</span><span class="hl-1">(</span><span class="hl-0">value</span><span class="hl-1">, </span><span class="hl-8">2</span><span class="hl-1">)</span><br/><span class="hl-1">		</span><span class="hl-3">if</span><span class="hl-1"> (!</span><span class="hl-7">isNaN</span><span class="hl-1">(</span><span class="hl-0">asNum</span><span class="hl-1">)) </span><span class="hl-0">finalValue</span><span class="hl-1"> = </span><span class="hl-0">asNum</span><br/><span class="hl-1">		</span><span class="hl-3">if</span><span class="hl-1"> ([</span><span class="hl-4">&quot;true&quot;</span><span class="hl-1">,</span><span class="hl-4">&quot;false&quot;</span><span class="hl-1">].</span><span class="hl-7">includes</span><span class="hl-1">(</span><span class="hl-0">value</span><span class="hl-1">)) {</span><br/><span class="hl-1">			</span><span class="hl-0">finalValue</span><span class="hl-1"> = </span><span class="hl-0">value</span><span class="hl-1"> === </span><span class="hl-4">&quot;true&quot;</span><span class="hl-1"> ? </span><span class="hl-5">true</span><span class="hl-1"> : </span><span class="hl-5">false</span><br/><span class="hl-1">		}</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">	</span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-0">isRegex</span><span class="hl-1">) {</span><br/><span class="hl-1">		</span><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-6">val</span><span class="hl-1"> = </span><span class="hl-0">value</span><span class="hl-1"> </span><span class="hl-3">as</span><span class="hl-1"> </span><span class="hl-9">string</span><span class="hl-1"> </span><span class="hl-2">// it&#39;s always a string and never prefixed if it&#39;s a regex</span><br/><span class="hl-1">		</span><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-6">regex</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-7">RegExp</span><span class="hl-1">(</span><span class="hl-0">val</span><span class="hl-1">, </span><span class="hl-0">regexFlags</span><span class="hl-1">) </span><span class="hl-2">// this can throw if the user passes invalid flags</span><br/><span class="hl-1">		</span><span class="hl-0">finalValue</span><span class="hl-1"> = </span><span class="hl-0">regex</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">	</span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-0">operator</span><span class="hl-1">) {</span><br/><span class="hl-1">		</span><span class="hl-3">switch</span><span class="hl-1"> (</span><span class="hl-0">operator</span><span class="hl-1"> </span><span class="hl-3">as</span><span class="hl-1"> </span><span class="hl-9">RawOperators</span><span class="hl-1">) {</span><br/><span class="hl-1">			</span><span class="hl-3">case</span><span class="hl-1"> </span><span class="hl-4">&quot;&gt;&quot;</span><span class="hl-1">: {</span><br/><span class="hl-1">				</span><span class="hl-0">finalOperator</span><span class="hl-1"> = </span><span class="hl-4">&quot;contains&quot;</span><br/><span class="hl-1">				</span><span class="hl-3">break</span><br/><span class="hl-1">			}</span><br/><span class="hl-1">			</span><span class="hl-3">case</span><span class="hl-1"> </span><span class="hl-4">&quot;contains&quot;</span><span class="hl-1">: {</span><br/><span class="hl-1">				</span><span class="hl-0">finalOperator</span><span class="hl-1"> = </span><span class="hl-4">&quot;contains&quot;</span><br/><span class="hl-1">				</span><span class="hl-3">break</span><br/><span class="hl-1">			}</span><br/><span class="hl-1">		}</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">	</span><span class="hl-3">return</span><span class="hl-1"> {</span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-0">finalValue</span><span class="hl-1">, </span><span class="hl-0">operator:</span><span class="hl-1"> </span><span class="hl-0">finalOperator</span><span class="hl-1">, </span><span class="hl-0">negate:</span><span class="hl-1"> </span><span class="hl-0">isNegated</span><span class="hl-1"> }</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>In this example, nothing was done with <code>isNegated</code>, but there are cases where you might need to change it. For example, you could choose to convert certain operators to others to reduce the number of operators you have to implement (e.g. convert all <code>lt/e</code> to <code>gt/e</code> to only have to implement <code>gt/e</code>). When you invert such operators, you also have to invert <code>isNegated</code>.</p>
</div><div class="tsd-comment tsd-typography"></div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">custom<wbr/>Property<wbr/>Operators</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><p>Allows the use short property condition operators in the form <code>prop[OP]variable</code> or <code>prop[OP](group)</code>. Where <code>OP</code> is one the given operators.</p>
<p>The operators can only be one or two characters long (with two character operators having priority), and they are added to the list of symbols that must be escaped.</p>
<p>For example, allowing the use of <code>&lt;</code>, <code>&gt;</code>, etc.:</p>
<pre><code class="js"><span class="hl-0">date</span><span class="hl-1">&gt;</span><span class="hl-8">2020</span><br/><span class="hl-0">date</span><span class="hl-1">=(</span><span class="hl-8">2020</span><span class="hl-1"> </span><span class="hl-6">OR</span><span class="hl-1"> </span><span class="hl-8">2021</span><span class="hl-1">)</span>
</code><button type="button">Copy</button></pre>

<p>The same operator as the expanded property separator can be passed and it will take priority (e.g. <code>{expandedPropertySeparator: &quot;:&quot;, customPropertyOperators:[&quot;:&quot;]}</code>).</p>
<p>For example, we might want <code>:</code> to mean <code>contains</code>:</p>
<pre><code class="js"><span class="hl-10">title</span><span class="hl-1">:(</span><span class="hl-0">a</span><span class="hl-1"> </span><span class="hl-6">OR</span><span class="hl-1"> </span><span class="hl-0">b</span><span class="hl-1">) </span><span class="hl-2">// title:a OR title:B</span><br/><span class="hl-10">title</span><span class="hl-1">:(</span><span class="hl-0">a</span><span class="hl-1"> </span><span class="hl-6">AND</span><span class="hl-1"> </span><span class="hl-0">b</span><span class="hl-1">) </span><span class="hl-2">// title:a AND title:B</span>
</code><button type="button">Copy</button></pre>

<p>Since these are just regular groups you can use them to allow making queries shorter:</p>
<pre><code class="js"><span class="hl-2">// if onMissingBooleanOperator = &quot;and&quot;</span><br/><span class="hl-10">title</span><span class="hl-1">:(</span><span class="hl-0">a</span><span class="hl-1"> </span><span class="hl-0">b</span><span class="hl-1">) </span><span class="hl-2">// title:a AND title:B</span><br/><span class="hl-2">// if prefixableGroups = true</span><br/><span class="hl-10">title</span><span class="hl-1">:(</span><span class="hl-7">prefix</span><span class="hl-1">(</span><span class="hl-0">a</span><span class="hl-1"> </span><span class="hl-6">OR</span><span class="hl-1"> </span><span class="hl-6">B</span><span class="hl-1">)) </span><span class="hl-2">// title:prefix.a OR title:prefix.b</span>
</code><button type="button">Copy</button></pre>

<p>Like expanded property operators, these are stored in the</p>
</div><div class="tsd-comment tsd-typography"><h4>See</h4><p>ConditionNode 's <code>property</code>, <code>propertyOperator</code> properties. <code>sep</code> is not used, not even if the the same operator as the <code>expandedPropertySeparator</code> is used. This is what is meant by these types of operators taking priority. If used in this short style, it will always be interpreted as a <code>propertyOperator</code>.</p>
</div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">expanded<wbr/>Property<wbr/>Separator</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span></h5><div class="tsd-comment tsd-typography"><p>Allows the use of expanded property condition operators in the form <code>prop[SEP]op[SEP]variable</code> or <code>prop[SEP]op(group)</code> where <code>SEP</code> is the given separator.</p>
<p>It is not necessary to pass a list of operators, since only characters that match the unquoted variable rules can be used.</p>
<p>For example, using <code>:</code>.</p>
<pre><code class="js"><span class="hl-10">title</span><span class="hl-1">:</span><span class="hl-10">contains</span><span class="hl-1">:</span><span class="hl-0">value</span><br/><span class="hl-10">title</span><span class="hl-1">:</span><span class="hl-7">contains</span><span class="hl-1">(</span><span class="hl-0">value</span><span class="hl-1">)</span>
</code><button type="button">Copy</button></pre>

<p>The information for these types of conditions are stored in a</p>
</div><div class="tsd-comment tsd-typography"><h4>See</h4><ul>
<li>ConditionNode 's <code>property</code>, <code>propertyOperator</code>, and <code>sep</code> properties.</li>
</ul>
<p>The separator can only be one character long and is added to the list of characters that need to be escaped.</p>
<p>The property is always a</p>
<ul>
<li>VariableNode and can be a quoted variable, but it can never be a prefixed string (if using <code>prefixableStrings</code>).</li>
</ul>
<pre><code>
</code><button>Copy</button></pre>

</div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">key<wbr/>Parser</span><span class="tsd-signature-symbol">?: </span><a href="index.KeyParser.html" class="tsd-signature-type tsd-kind-type-alias">KeyParser</a></h5><div class="tsd-comment tsd-typography"><p>The ParserOption.prefixApplier can only apply prefixes and cannot tell us how to get the value from a context object when using evaluate.</p>
<p>This functions tells us how to actually interpret the key to be able to get it from the context. It is passed the result of the prefixApplier and should return an array of keys.</p>
<p>The default parser only returns the value wrapped in an array.</p>
<p>So for example, given <code>&quot;category.subcategory.variable&quot;</code>, it would return <code>[&quot;category.subcategory.variable&quot;]</code> and require the context object to look like:</p>
<pre><code class="ts"><span class="hl-1">{</span><br/><span class="hl-1">	</span><span class="hl-4">&quot;category.subcategory.variable1&quot;</span><span class="hl-1"> : </span><span class="hl-2">//value</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>If your context object contains nested values, you would need to specify a function that returns the keys needed to access the value in an array. For example:</p>
<pre><code class="ts"><span class="hl-2">// context</span><br/><span class="hl-1">{</span><br/><span class="hl-1">	</span><span class="hl-10">category</span><span class="hl-1">: {</span><br/><span class="hl-1">		</span><span class="hl-10">subcategory</span><span class="hl-1">: {</span><br/><span class="hl-1">			</span><span class="hl-10">variable</span><span class="hl-1">: </span><span class="hl-2">//value</span><br/><span class="hl-1">		}</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">}</span><br/><span class="hl-2">// given:</span><br/><span class="hl-4">&quot;category.subcategory.variable&quot;</span><br/><span class="hl-2">// we can use a getter like:</span><br/><br/><span class="hl-1">{</span><br/><span class="hl-1">	</span><span class="hl-2">//...</span><br/><span class="hl-1">	</span><span class="hl-10">keyParser</span><span class="hl-1">: (</span><span class="hl-0">key</span><span class="hl-1">:</span><span class="hl-9">string</span><span class="hl-1">) </span><span class="hl-5">=&gt;</span><span class="hl-1"> </span><span class="hl-0">key</span><span class="hl-1">.</span><span class="hl-7">split</span><span class="hl-1">(</span><span class="hl-4">&quot;.&quot;</span><span class="hl-1">)</span><br/><span class="hl-1">	</span><span class="hl-2">//...</span><br/><span class="hl-1">}</span><br/><span class="hl-2">// which would return:</span><br/><span class="hl-1">[</span><span class="hl-4">&quot;category&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;subcategory&quot;</span><span class="hl-1">, </span><span class="hl-4">&quot;variable&quot;</span><span class="hl-1">]</span><br/>
</code><button type="button">Copy</button></pre>

</div><div class="tsd-comment tsd-typography"></div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">keywords</span><span class="tsd-signature-symbol">?: </span><a href="index.KeywordOptions.html" class="tsd-signature-type tsd-kind-type-alias">KeywordOptions</a></h5><div class="tsd-comment tsd-typography"><p>An object where each of the the three keys (or/and/not) contains a list of keyword operator entries.</p>
<p>If nothing is passed, the following defaults are used:</p>
<pre><code class="ts"><span class="hl-10">keywords</span><span class="hl-1">: {</span><br/><span class="hl-1">	</span><span class="hl-10">or</span><span class="hl-1">: [</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;||&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">true</span><span class="hl-1"> },</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;|&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">true</span><span class="hl-1"> },</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;or&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1"> },</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;OR&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1"> },</span><br/><span class="hl-1">	],</span><br/><span class="hl-1">	</span><span class="hl-10">and</span><span class="hl-1">: [</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;&amp;&amp;&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">true</span><span class="hl-1"> },</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;&amp;&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">true</span><span class="hl-1"> },</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;and&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1"> },</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;AND&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1"> },</span><br/><span class="hl-1">	],</span><br/><span class="hl-1">		</span><span class="hl-10">not</span><span class="hl-1">: [</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;!&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">true</span><span class="hl-1"> },</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;not&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1"> },</span><br/><span class="hl-1">		{ </span><span class="hl-0">value:</span><span class="hl-1"> </span><span class="hl-4">&quot;NOT&quot;</span><span class="hl-1">, </span><span class="hl-0">isSymbol:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1"> },</span><br/><span class="hl-1">	],</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p><code>isSymbol</code> just tells the parser to treat the value as a symbol, not necessarily that it <em>is</em> a symbol (the parser make no distinction between character types). For example, you could pass <code>{ value: &quot;and&quot;, isSymbol: true }</code>, but this would cause just <code>and</code> to require quoting or escaping to be parsed as a variable, and values like <code>andromeda</code> to be parsed as <code>and romeda</code>.</p>
<p>You might think this means something similar to not requiring whitespace, but it's not. The parser is as lenient as possible and even if <code>isSymbol</code> is false, there are cases where whitespace is not needed because it is clear the keyword is not part of a value, (e.g. <code>not(a)</code>).</p>
</div><div class="tsd-comment tsd-typography"></div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">on<wbr/>Missing<wbr/>Boolean<wbr/>Operator</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">&quot;error&quot;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">&quot;and&quot;</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-type">&quot;or&quot;</span></h5><div class="tsd-comment tsd-typography"><p>Allows controlling what happens when a boolean operator is missing. <code>error</code> is the default, which will insert an error token (expecting any operator).</p>
<p>If <code>and</code>, no error token is inserted, instead a zero length AND token is used for the operator.
If <code>or</code>, no error token is inserted, instead a zero length OR token is used for the operator.</p>
<p>Note that the invisible operator will still have it's precedence, so the ast will look different depending if you default to and than if you default to or.</p>
<p>My suggestion is default to <code>and</code> if you want to default to something because:</p>
<ul>
<li>It's likely if the user is aware of this feature they will only use no-symbol + the opposite symbol. In which case, which looks clearer?<pre><code><span class="hl-1">	</span><span class="hl-0">a</span><span class="hl-1"> </span><span class="hl-0">b</span><span class="hl-1"> || </span><span class="hl-7">c</span><span class="hl-1"> (</span><span class="hl-0">defaulting</span><span class="hl-1"> </span><span class="hl-0">to</span><span class="hl-1"> </span><span class="hl-0">and</span><span class="hl-1">)</span><br/><span class="hl-1">	</span><span class="hl-0">a</span><span class="hl-1"> </span><span class="hl-0">b</span><span class="hl-1"> &amp;&amp; </span><span class="hl-7">c</span><span class="hl-1"> (</span><span class="hl-0">defaulting</span><span class="hl-1"> </span><span class="hl-0">to</span><span class="hl-1"> </span><span class="hl-0">or</span><span class="hl-1">)</span>
</code><button>Copy</button></pre>

</li>
<li>If searching through a lot of data, evaluation of expressions will be faster since it encourages not using an operator, and therefore using <code>and</code> which will short circuit conditions earlier.</li>
</ul>
</div><div class="tsd-comment tsd-typography"></div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">prefix<wbr/>Applier</span><span class="tsd-signature-symbol">?: </span><a href="index.PrefixApplier.html" class="tsd-signature-type tsd-kind-type-alias">PrefixApplier</a></h5><div class="tsd-comment tsd-typography"><p>If prefixableGroups is true, this allows you to control how a prefix is applied for any methods that need to apply them (e.g.</p>
</div><div class="tsd-comment tsd-typography"><h4>See</h4><ul>
<li>extractVariables</li>
<li>evaluate).</li>
</ul>
<p>The default</p>
<ul>
<li>PrefixApplier function just appends the prefix.</li>
</ul>
<p>So for example:</p>
<pre><code class="js"><span class="hl-0">category</span><span class="hl-1">.</span><span class="hl-0">subcategory</span><span class="hl-1">.(</span><span class="hl-0">variable1</span><span class="hl-1"> || </span><span class="hl-0">variable2</span><span class="hl-1">)</span><br/><span class="hl-2">// = category.subcategory.variable1 || category.subcategory.variable2</span><br/><br/><span class="hl-4">&quot;category subcategory &quot;</span><span class="hl-1">(</span><span class="hl-0">variable1</span><span class="hl-1"> || </span><span class="hl-0">variable2</span><span class="hl-1">)</span><br/><span class="hl-2">// = &quot;category subcategory variable1&quot; || &quot;category subcategory variable2&quot;</span><br/><br/><span class="hl-2">// negations also work:</span><br/><span class="hl-1">!</span><span class="hl-0">category</span><span class="hl-1">.(</span><span class="hl-0">subcategory</span><span class="hl-1">.(</span><span class="hl-0">variable1</span><span class="hl-1"> || !</span><span class="hl-0">variable2</span><span class="hl-1">))</span><br/><span class="hl-2">// = !category.subcategory.variable1 || category.subcategory.variable2</span>
</code><button type="button">Copy</button></pre>

<p>But, for example, you might want to be less strict and allow things like <code>prefix(var)</code> to get converted to <code>prefix.var</code> instead of <code>prefixvar</code>. To do so, you can pass a function like this one.</p>
<pre><code class="ts"><span class="hl-1">{</span><br/><span class="hl-1">	</span><span class="hl-2">// ...</span><br/><span class="hl-1">	</span><span class="hl-10">prefixableGroups</span><span class="hl-1">: </span><span class="hl-5">true</span><span class="hl-1">,</span><br/><span class="hl-1">	</span><span class="hl-10">prefixApplier</span><span class="hl-1">: (</span><span class="hl-0">prefix</span><span class="hl-1">:</span><span class="hl-9">string</span><span class="hl-1">, </span><span class="hl-0">variable</span><span class="hl-1">: </span><span class="hl-9">string</span><span class="hl-1">) </span><span class="hl-5">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">		</span><span class="hl-3">if</span><span class="hl-1"> (!</span><span class="hl-0">prefix</span><span class="hl-1">.</span><span class="hl-7">endsWith</span><span class="hl-1">(</span><span class="hl-4">&quot;.&quot;</span><span class="hl-1">)) {</span><br/><span class="hl-1">			</span><span class="hl-3">return</span><span class="hl-1"> </span><span class="hl-4">`</span><span class="hl-5">${</span><span class="hl-0">prefix</span><span class="hl-5">}</span><span class="hl-4">.</span><span class="hl-5">${</span><span class="hl-0">variable</span><span class="hl-5">}</span><span class="hl-4">`</span><br/><span class="hl-1">		}</span><br/><span class="hl-1">		</span><span class="hl-3">return</span><span class="hl-1"> </span><span class="hl-0">prefix</span><span class="hl-1"> + </span><span class="hl-0">variable</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">	</span><span class="hl-2">// ...</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">prefixable<wbr/>Groups</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span></h5><div class="tsd-comment tsd-typography"><p>Allows any conditions (i.e. a variable or negated variable) to precede groups and append themselves to all variables inside them. Regular use of groups for changing precedence (e.g. <code>(a || b) &amp;&amp; c</code> ) or negating expressions <code>!(a || b)</code> is still supported even if <code>prefixableGroups</code> is false.</p>
<p>For example:</p>
<pre><code class="js"><span class="hl-0">category</span><span class="hl-1">.</span><span class="hl-0">subcategory</span><span class="hl-1">.(</span><span class="hl-0">variable1</span><span class="hl-1"> || </span><span class="hl-0">variable2</span><span class="hl-1"> &amp;&amp; !</span><span class="hl-0">variable3</span><span class="hl-1">)</span>
</code><button type="button">Copy</button></pre>

<p>returns an</p>
</div><div class="tsd-comment tsd-typography"><h4>See</h4><ul>
<li>GroupNode whose prefix is a value token with the value <code>category.subcategory.</code></li>
</ul>
<p>This prefix can later be applied by utility functions when evaluating the expression or extracting information from it. The default</p>
<ul>
<li>PrefixApplier appends the prefix name to every variable inside the group, so the above would expand into something like:</li>
</ul>
<pre><code class="js"><span class="hl-0">category</span><span class="hl-1">.</span><span class="hl-0">subcategory</span><span class="hl-1">.</span><span class="hl-0">variable1</span><span class="hl-1"> || </span><span class="hl-0">category</span><span class="hl-1">.</span><span class="hl-0">subcategory</span><span class="hl-1">.</span><span class="hl-0">variable2</span><span class="hl-1"> || !</span><span class="hl-0">category</span><span class="hl-1">.</span><span class="hl-0">subcategory</span><span class="hl-1">.</span><span class="hl-0">variable3</span>
</code><button type="button">Copy</button></pre>

<ul>
<li>UtilityOptions[&quot;prefixApplier&quot;] for more examples and details on how to customize the behavior.</li>
</ul>
</div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">prefixable<wbr/>Strings</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">string</span><span class="tsd-signature-symbol">[]</span></h5><div class="tsd-comment tsd-typography"><p>If defined, allows the given &quot;list&quot; of unquoted &quot;variables&quot; to precede quoted ones, creating a prefixed string.</p>
<p>This is useful for &quot;tagging&quot; strings so you can interpret them as something else. For example, you could have a string prefix, <code>num</code> for allowing users to pass strings that will be interpreted as numbers when you would normally not be able to tell if it's a number (e.g.<code>num&quot;0.1&quot;</code>, <code>num&quot;1,000&quot;</code>) .</p>
<p>A known &quot;list&quot; is needed, otherwise, error handling is not as nice in some cases.</p>
</div><div class="tsd-comment tsd-typography"></div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">regex<wbr/>Values</span><span class="tsd-signature-symbol">?: </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol"> | </span><span class="tsd-signature-symbol">(</span><span class="tsd-signature-symbol">(</span><span class="tsd-kind-parameter">property</span>, <span class="tsd-kind-parameter">operator</span>, <span class="tsd-kind-parameter">isExpanded</span><span class="tsd-signature-symbol">)</span><span class="tsd-signature-symbol"> =&gt; </span><span class="tsd-signature-type">boolean</span><span class="tsd-signature-symbol">)</span></h5><div class="tsd-comment tsd-typography"><p>Enables regex strings as values. The value is treated as if it was quoted by forward slashes. Any repetition of lowercase characters (even if there are multiple) attached to the end are assumed to be flags and added as a single token to the value's <code>quotes.mode</code> property.</p>
<p>Can be passed a custom function to determine when to use the regex value or not (it is converted to a regular value). The function is passed the property, the operator, and whether it's an expanded operator. If their is an error token for the property or operator, an empty string is passed.</p>
<pre><code class="ts"><span class="hl-2">// allow anything (`prop=/val/`, `prop:op:/val`, `prop=(/val/)`, `prop:op(/val/)`) but the value alone (`/regex/`)</span><br/><span class="hl-10">regexValues</span><span class="hl-1">: (</span><span class="hl-0">property</span><span class="hl-1">, </span><span class="hl-0">operator</span><span class="hl-1">, </span><span class="hl-0">isExpanded</span><span class="hl-1">) </span><span class="hl-5">=&gt;</span><span class="hl-1"> </span><span class="hl-3">return</span><span class="hl-1"> </span><span class="hl-0">property</span><span class="hl-1"> !== </span><span class="hl-5">undefined</span><span class="hl-1"> || </span><span class="hl-0">operator</span><span class="hl-1"> !== </span><span class="hl-5">undefined</span><br/><span class="hl-2">// only allow for a certain custom operator (not expanded) (`prop=/val/` but not `prop:op:/val/` or `prop:op(/val/)`)</span><br/><span class="hl-10">regexValues</span><span class="hl-1">: (</span><span class="hl-0">property</span><span class="hl-1">, </span><span class="hl-0">operator</span><span class="hl-1">, </span><span class="hl-0">isExpanded</span><span class="hl-1">) </span><span class="hl-5">=&gt;</span><span class="hl-1"> </span><span class="hl-3">return</span><span class="hl-1"> !</span><span class="hl-0">isExpanded</span><span class="hl-1"> &amp;&amp; </span><span class="hl-0">operator</span><span class="hl-1"> === </span><span class="hl-4">&quot;=&quot;</span>
</code><button type="button">Copy</button></pre>

<p>Notes:</p>
<ul>
<li>
<p>Usually you should only actually allow <code>i</code>, <code>m</code>, and <code>u</code> since the others would make no sense for a query language and would bring down performance.</p>
</li>
<li>
<p>Unlike quoted values we can't fix errors like <code>... val/ ...</code>. If the <code>/</code> were a quote, we can tell a quote is missing before the val, but with regexes, it will just swallow ALL the input AFTER.</p>
</li>
</ul>
<p>There is also the following cases that might seem strange:</p>
<pre><code><span class="hl-1">... /[/ ...</span><br/><span class="hl-1">    ^</span><span class="hl-0">start</span><span class="hl-1"> .... </span><span class="hl-0">no</span><span class="hl-1"> </span><span class="hl-0">end</span><br/><span class="hl-1">... /[</span><span class="hl-11">/ ... /</span><span class="hl-1">...../</span><br/><span class="hl-1">    ^       ^     ^</span><br/><span class="hl-1">    </span><span class="hl-0">start</span><span class="hl-1">   | </span><span class="hl-0">end</span><span class="hl-1"> | </span><span class="hl-0">start</span><br/>
</code><button>Copy</button></pre>

<p>They <em>seem</em> to incorrectly swallow all input after or until the next <code>/</code>, but this is correct and happens because forward slashes do not need to be escaped inside regex sets (i.e. <code>[]</code>). And even if the regex is invalid and the set is never closed, we can't tell the set isn't closed when parsing. This is also why it would be very hard to create smarter errors like quoted values have.</p>
</div><div class="tsd-comment tsd-typography"></div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">value<wbr/>Comparer</span><span class="tsd-signature-symbol">?: </span><a href="index.ValueComparer.html" class="tsd-signature-type tsd-kind-type-alias">ValueComparer</a></h5><div class="tsd-comment tsd-typography"><p>When evaluating an ast against a context, this function determines whether a context value satisfies a condition.</p>
<p>Given a partial <a href="../classes/index.ast.Condition.html">Condition</a> instance (negate property is not passed) and the contextValue (as extracted using <a href="../classes/index.ast.Condition.html#property">Condition.property</a>), it should return whether the values are equal.</p>
<p>It is also passed the context itself for cases where there is no property and you might want to check the value against all properties of the context.</p>
<p>A default comparer is available but it just checks the context value against the query value for strict equality.</p>
<pre><code class="ts"><span class="hl-5">type</span><span class="hl-1"> </span><span class="hl-9">Operators</span><span class="hl-1"> = </span><span class="hl-4">&quot;contains&quot;</span><br/><span class="hl-5">function</span><span class="hl-1"> </span><span class="hl-7">valueComparer</span><span class="hl-1">(</span><span class="hl-0">condition</span><span class="hl-1">: </span><span class="hl-9">Omit</span><span class="hl-1">&lt;</span><span class="hl-9">Condition</span><span class="hl-1">, </span><span class="hl-4">&quot;negate&quot;</span><span class="hl-1">&gt;, </span><span class="hl-0">contextValue</span><span class="hl-1">: </span><span class="hl-9">any</span><span class="hl-1">, </span><span class="hl-0">context</span><span class="hl-1">: </span><span class="hl-9">any</span><span class="hl-1">): </span><span class="hl-9">boolean</span><span class="hl-1"> {</span><br/><span class="hl-1">	</span><span class="hl-3">switch</span><span class="hl-1"> (</span><span class="hl-0">operator</span><span class="hl-1"> </span><span class="hl-3">as</span><span class="hl-1"> </span><span class="hl-9">Operators</span><span class="hl-1">) {</span><br/><span class="hl-1">		</span><span class="hl-3">case</span><span class="hl-1"> </span><span class="hl-4">&quot;contains&quot;</span><span class="hl-1">: </span><span class="hl-3">return</span><span class="hl-1"> (</span><span class="hl-0">contextValue</span><span class="hl-1"> </span><span class="hl-3">as</span><span class="hl-1"> </span><span class="hl-9">string</span><span class="hl-1">[]).</span><span class="hl-7">includes</span><span class="hl-1">(</span><span class="hl-0">condition</span><span class="hl-1">.</span><span class="hl-0">value</span><span class="hl-1"> </span><span class="hl-3">as</span><span class="hl-1"> </span><span class="hl-9">string</span><span class="hl-1">)</span><br/><span class="hl-1">		</span><span class="hl-2">// ...</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">	</span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-0">condition</span><span class="hl-1">.</span><span class="hl-0">property</span><span class="hl-1">.</span><span class="hl-0">length</span><span class="hl-1"> === </span><span class="hl-8">0</span><span class="hl-1">) {</span><br/><span class="hl-1">		</span><span class="hl-2">// no property was given, contextValue is always undefined</span><br/><span class="hl-1">		</span><span class="hl-2">// attempt to match against all properties</span><br/><span class="hl-1">		</span><span class="hl-3">return</span><span class="hl-1"> </span><span class="hl-0">Object</span><span class="hl-1">.</span><span class="hl-7">values</span><span class="hl-1">(</span><span class="hl-0">context</span><span class="hl-1">).</span><span class="hl-7">find</span><span class="hl-1">(</span><span class="hl-0">anyContextValue</span><span class="hl-1"> </span><span class="hl-5">=&gt;</span><span class="hl-1"> </span><span class="hl-0">anyContextValue</span><span class="hl-1">.</span><span class="hl-7">match</span><span class="hl-1">(</span><span class="hl-0">condition</span><span class="hl-1">.</span><span class="hl-0">value</span><span class="hl-1">) !== </span><span class="hl-5">undefined</span><span class="hl-1">) !== </span><span class="hl-5">undefined</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</div><div class="tsd-comment tsd-typography"></div></li><li class="tsd-parameter"><h5><code class="tsd-tag ts-flagOptional">Optional</code> <span class="tsd-kind-property">value<wbr/>Validator</span><span class="tsd-signature-symbol">?: </span><a href="index.ValueValidator.html" class="tsd-signature-type tsd-kind-type-alias">ValueValidator</a><span class="tsd-signature-symbol">&lt;</span><a class="tsd-signature-type tsd-kind-type-parameter" href="index.ParserOptions.html#T">T</a><span class="tsd-signature-symbol">&gt;</span></h5><div class="tsd-comment tsd-typography"><p>Similar to the valueComparer but for validating the ast before it's evaluated using</p>
</div><div class="tsd-comment tsd-typography"><h4>See</h4><p>Parser[&quot;validate&quot;] (e.g. for syntax highlighting purposes). For the moment the ast must be valid (without syntax errors) to be validated.</p>
<p>The only difference is nothing is actually evaluated (even though the values are available to the function*) and the query contains the actual nodes/tokens for certain properties to make extracting positions easier.</p>
<p>The function should return any positions of interest. These are collected and are returned as the result of the validate method. Basically it makes it easy to &quot;tag&quot; ranges. You're not restricted to returning just the position and you can use the generic argument to type additional properties you might return.</p>
<p>* The validate function won't attempt to fetch context values if no context is passed to the validate method (in which case the contextValue parameter will just be undefined).</p>
<p>Example:
Say we had a context that had a single nested key <code>a.b.c.d.e</code>.</p>
<p>If a user inputs <code>a(c(d)) || e</code> we want to highlight all the prefixes from the first invalid &quot;branch&quot; (<code>c</code>). In the case of this input, the validator function is called for each innermost value (so twice, once for <code>d</code> and once for <code>e</code>).</p>
<p>The first time (for <code>d</code>), the validator would receive a query whose <code>property</code> property would contain an array like: <code>[ValidToken(a), ValidToken(c), ValidToken(d)]</code>. We can do something like the following to &quot;tag&quot; <code>c</code> as the root of the problem, <code>d</code> as a sort of continuation of that error.</p>
<p>Then the second time we will receive <code>[ValidToken(e)]</code>, which we can &quot;tag&quot; as some other error.</p>
<pre><code class="ts"><span class="hl-7">valueValidator</span><span class="hl-1">(</span><span class="hl-0">_contextValue</span><span class="hl-1">, </span><span class="hl-0">query</span><span class="hl-1">, </span><span class="hl-0">context</span><span class="hl-1">) {</span><br/><span class="hl-1">	</span><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-6">values</span><span class="hl-1"> = </span><span class="hl-0">query</span><span class="hl-1">.</span><span class="hl-0">propertyKeys</span><br/><span class="hl-1">	</span><span class="hl-5">let</span><span class="hl-1"> </span><span class="hl-0">i</span><span class="hl-1"> = </span><span class="hl-8">1</span><br/><span class="hl-1">	</span><span class="hl-2">// where `get` is something like lodash&#39;s get</span><br/><span class="hl-1">	</span><span class="hl-3">while</span><span class="hl-1"> (</span><span class="hl-0">i</span><span class="hl-1"> &lt; </span><span class="hl-0">query</span><span class="hl-1">.</span><span class="hl-0">property</span><span class="hl-1">.</span><span class="hl-0">length</span><span class="hl-1"> &amp;&amp; </span><span class="hl-7">get</span><span class="hl-1">(</span><span class="hl-0">context</span><span class="hl-1">, </span><span class="hl-0">values</span><span class="hl-1">.</span><span class="hl-7">slice</span><span class="hl-1">(</span><span class="hl-8">0</span><span class="hl-1">, </span><span class="hl-0">i</span><span class="hl-1">)) !== </span><span class="hl-5">undefined</span><span class="hl-1">) {</span><br/><span class="hl-1">		</span><span class="hl-0">i</span><span class="hl-1">++</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">	</span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-0">i</span><span class="hl-1"> !== </span><span class="hl-8">0</span><span class="hl-1">) {</span><br/><span class="hl-1">		</span><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-6">invalid</span><span class="hl-1"> = </span><span class="hl-0">query</span><span class="hl-1">.</span><span class="hl-0">property</span><span class="hl-1">.</span><span class="hl-7">slice</span><span class="hl-1">(</span><span class="hl-0">i</span><span class="hl-1"> - </span><span class="hl-8">1</span><span class="hl-1">, </span><span class="hl-0">query</span><span class="hl-1">.</span><span class="hl-0">property</span><span class="hl-1">.</span><span class="hl-0">length</span><span class="hl-1">)</span><br/><span class="hl-1">			.</span><span class="hl-7">map</span><span class="hl-1">(</span><span class="hl-0">node</span><span class="hl-1"> </span><span class="hl-5">=&gt;</span><span class="hl-1"> ({</span><br/><span class="hl-1">				</span><span class="hl-2">// use the node position to include any quotes in the position</span><br/><span class="hl-1">				</span><span class="hl-0">start:</span><span class="hl-1"> </span><span class="hl-0">node</span><span class="hl-1">.</span><span class="hl-0">start</span><span class="hl-1">,</span><br/><span class="hl-1">				</span><span class="hl-0">end:</span><span class="hl-1"> </span><span class="hl-0">node</span><span class="hl-1">.</span><span class="hl-0">end</span><span class="hl-1">,</span><br/><span class="hl-1">				</span><span class="hl-0">type:</span><span class="hl-1"> </span><span class="hl-4">&quot;InvalidPrefix&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">			}))</span><br/><span class="hl-1">			</span><span class="hl-0">invalid</span><span class="hl-1">[</span><span class="hl-8">0</span><span class="hl-1">].</span><span class="hl-0">type</span><span class="hl-1"> = </span><span class="hl-0">query</span><span class="hl-1">.</span><span class="hl-0">property</span><span class="hl-1">.</span><span class="hl-0">length</span><span class="hl-1"> === </span><span class="hl-8">1</span><span class="hl-1"> ? </span><span class="hl-4">&quot;InvalidVariable&quot;</span><span class="hl-1"> : </span><span class="hl-4">&quot;InvalidPrefixBranch&quot;</span><br/><span class="hl-1">		</span><span class="hl-3">return</span><span class="hl-1"> </span><span class="hl-0">invalid</span><br/><span class="hl-1">	}</span><br/><span class="hl-1">}</span><br/><span class="hl-2">// ...later</span><br/><span class="hl-2">// context could be a dummy context where all known properties are just true</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-6">errors</span><span class="hl-1"> =&gt; </span><span class="hl-0">parser</span><span class="hl-1">.</span><span class="hl-7">validate</span><span class="hl-1">(</span><span class="hl-0">ast</span><span class="hl-1">, </span><span class="hl-0">context</span><span class="hl-1">)</span><br/><span class="hl-2">// ... use the information to highlight those locations accordingly</span><br/><span class="hl-2">// a(c(d || e))</span><br/><span class="hl-2">//          ^InvalidVariable</span><br/><span class="hl-2">//     ^InvalidPrefix</span><br/><span class="hl-2">//   ^InvalidPrefixBranch</span>
</code><button type="button">Copy</button></pre>

</div></li></ul></div><aside class="tsd-sources"><ul><li>Defined in <a href="https://github.com/witchcraftjs/expressit/blob/6b331253fc81813cf3a5e0fa280383c870f9865f/src/types/parser.ts#L26">types/parser.ts:26</a></li></ul></aside></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-index-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div></div><div class="site-menu"><nav id="tsd-sidebar-links" class="tsd-navigation"><a href="https://github.com/witchcraftjs/expressit" class="tsd-nav-link">Github</a><a href="https://github.com/witchcraftjs/expressit/issues" class="tsd-nav-link">Issues</a><a href="http://npmjs.com/@witchcraft/expressit" class="tsd-nav-link">npm</a></nav><nav class="tsd-navigation"><a href="../index.html"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-1"></use></svg><span>@witchcraft/expressit</span></a><ul class="tsd-small-nested-navigation" id="tsd-nav-container" data-base=".."><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>