(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))o(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const s of n.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&o(s)}).observe(document,{childList:!0,subtree:!0});function r(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function o(i){if(i.ep)return;i.ep=!0;const n=r(i);fetch(i.href,n)}})();const style="";function evalTemplateString(e,t){let r="";for(let o=0;o<e.length;o++){const i=e[o];r+=i+(o<t.length?t[o]:"")}return r}function isDefined(e){return e!==void 0}function stripIndent(e,{tabs:t=!0,count:r=void 0}={}){let o=r;if(!isDefined(o)){const s=t?/^[\t]*(?=[^\t])/gm:/^[ ]*(?=[^ ])/gm,a=e.match(s);if(a===null)return e;o=a.reduce((l,p)=>Math.min(l,p.length),1/0)}const i=o===1/0?"":o,n=new RegExp(`^${t?"\\t":" "}{0,${i}}`,"gm");return e.replace(n,"")}function trimLines(e){return e.replace(/(^\n*?(?=[^\n]|$))([\s\S]*?)(\n*?\s*?$)/,"$2")}function crop(e,...t){return stripIndent(trimLines(evalTemplateString(e,t)))}function indent(e,t=0,{first:r=!1}={}){const o=r?/(^|\n)/g:/\n/g,i="	".repeat(t),n=r?`$1${i}`:`
${i}`;return e.replace(o,n)}const keys=Object.keys;function walk(e,t,r={}){const o=[...arguments[3]??[]];if(r.before){const n=t?t(e,o,"before"):e;r.save&&(e=n)}let i;if(Array.isArray(e)){const n=[];let s=0;for(const a of e){const l=[...o,s.toString()],p=typeof a=="object"&&a!==null?walk(a,t,r,l):t?t(a,l):a;r.save&&p!==void 0&&n.push(p),s++}i=r.save?n:void 0}else if(e!==null){const n={};for(const s of keys(e)){const a=[...o,s.toString()],l=e[s],p=typeof l=="object"&&l!==null?walk(l,t,r,a):t?t(l,a):l;r.save&&p!==void 0&&(n[s]=p)}i=r.save?n:void 0}else if(e===null){const n=t?t(e,o):e;i=r.save?n:void 0}if(r.after){const n=t?t(i,o,"after"):i;r.save&&(i=n)}return i}function pretty(e,{oneline:t=!1,stringify:r=!1}={}){let o=e;return r&&(r===!0&&(r=i=>typeof i=="function"||typeof i=="symbol"?i.toString():i),o=walk(e,(i,n)=>n.length===0?i:r(i),{save:!0,after:!0})),t?JSON.stringify(o,null,"|").replace(/\n\|*/g," "):JSON.stringify(o,null,"	")}const name="@witchcraft/expressit",description="A blazing fast, customizable, error-tolerant expression parser that creates safe to eval expressions + a few other goodies like autocomplete.",version$1="0.0.0-semantically-released",types="./dist/index.d.ts",type="module",module="./dist/index.js",sideEffects=!1,exports={".":{types:"./dist/index.d.ts",import:"./dist/index.js"},"./ast":{types:"./dist/ast/index.d.ts",import:"./dist/ast/index.js"},"./ast/*":{types:"./dist/ast/*",import:"./dist/ast/*"},"./helpers":{types:"./dist/helpers/index.d.ts",import:"./dist/helpers/index.js"},"./helpers/*":{types:"./dist/helpers/*",import:"./dist/helpers/*"},"./methods":{types:"./dist/methods/index.d.ts",import:"./dist/methods/index.js"},"./methods/*":{types:"./dist/methods/*",import:"./dist/methods/*"},"./utils":{types:"./dist/utils/index.d.ts",import:"./dist/utils/index.js"},"./utils/*":{types:"./dist/utils/*",import:"./dist/utils/*"},"./examples":{types:"./dist/examples/index.d.ts",import:"./dist/examples/index.js"},"./examples/*":{types:"./dist/examples/*",import:"./dist/examples/*"},"./*":{types:"./dist/types/*",import:"./dist/types/*"}},scripts={debug:"ts-node -r tsconfig-paths/register -T --esm",build:"vite build","build:dev":"vite build --mode development","build:watch":"vite build --watch --mode production","build:types":"tsc --emitDeclarationOnly -p tsconfig.types.json && npm run build:types:fix","build:types:fix":"tsc-alias -p tsconfig.types.json --debug","lint:eslint":'eslint "{src,tests,bin}/**/*.{cjs,js,ts}" "*.{cjs,js,ts}" --max-warnings=1 --report-unused-disable-directives',"lint:types":"tsc --noEmit --pretty","lint:commits":"commitlint --from $(git rev-list --max-parents=0 HEAD) --to HEAD --verbose","lint:imports":"madge --circular --extensions ts ./src",lint:"npm run lint:types && npm run lint:eslint",coverage:"vitest --exclude '.direnv/**/*' --coverage","coverage:dev":"vitest --exclude '.direnv/**/*'  --watch --coverage",test:"npm run lint:types && vitest run --exclude '.direnv/**/*'","test:watch":"vitest --watch --exclude '.direnv/**/*'","test:inspect-errors":"cross-env INSPECT_ERRORS=true npm run test",doc:"typedoc --options typedoc.config.cjs","doc:watch":'onchange -i "src/**/*.ts" "typedoc.config.cjs" -- npm run doc',"doc:serve":"http-server docs --port=5001","doc:dev":'concurrently "npm run doc:watch" "npm run doc:serve"',"doc:check-invalid":"typedoc --options typedoc.config.cjs --listInvalidSymbolLinks","demo:dev":'cd demo && concurrently "vite" "npm run build:watch"',"demo:build":"cd demo && npm run build","actions:debug":"act -r -v -j build","gen:exports":"indexit update -o '${path}.js' -i **/*.d.ts",prepare:"husky && npm run build"},dependencies={"@alanscodelog/utils":"^4.0.0"},devDependencies={"@alanscodelog/commitlint-config":"^3.0.1","@alanscodelog/eslint-config":"5.0.0-beta.3","@alanscodelog/semantic-release-config":"^4.1.2","@alanscodelog/tsconfigs":"^4.0.1","@commitlint/cli":"^19.3.0","@types/node":"^20.4.1","@vitest/coverage-v8":"^1.6.0",concurrently:"^8.2.0","cross-env":"^7.0.3","fast-glob":"^3.3.1","http-server":"^14.1.1",husky:"^9.0.11",indexit:"2.1.0-beta.3",madge:"^7.0.0",onchange:"^7.1.0","semantic-release":"^23.1.1","ts-node":"^10.9.1","tsc-alias":"^1.8.7",typedoc:"0.26.0-beta.1",typescript:"~5.4.5",vite:"^5.2.11","vite-plugin-externalize-deps":"^0.8.0","vite-tsconfig-paths":"^4.2.0",vitest:"^1.6.0"},author="Alan <alanscodelog@gmail.com>",repository$1="https://github.com/witchcraftjs/expressit",keywords=["boolean","parser","query","evaluator","expression","condition","search"],license="MIT",files=["src","dist"],release={extends:["@alanscodelog/semantic-release-config"]},commitlint={extends:["@alanscodelog"]},browserslist="defaults and supports es6-module,maintained node versions",engines={node:">=18.0.0"},publishConfig={access:"public"},pkg={name,description,version:version$1,types,type,module,sideEffects,exports,scripts,dependencies,devDependencies,author,repository:repository$1,keywords,license,files,release,commitlint,browserslist,engines,"@comments":{scripts:{test:"Runs `lint:types` before (so that flags can be passed to the test command) so that we can test type assertions. See expect_type function in @alanscodelog/utils.","lint:commits":"Lints all unpushed commits in the active branch.",prepare:"Needed so that if we pull the package from git it will get built and installed properly.","actions:debug":"For debugging github build action locally with nektos/act. Requires act and docker. Note: Cache will never work locally because of https://github.com/nektos/act/issues/285"}},publishConfig},version=pkg.version,repository=pkg.repository;var __defProp$d=Object.defineProperty,__defNormalProp$d=(e,t,r)=>t in e?__defProp$d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$d=(e,t,r)=>(__defNormalProp$d(e,typeof t!="symbol"?t+"":t,r),r);class BooleanParserLibraryError extends Error{constructor(t,r,o){super(o?`${o}
${pretty(r)}`:`This error should never happen, please file a bug report at ${repository}/issues with the following information: 
${crop`
					version: ${version}
					type: ${t}
					info: ${indent(JSON.stringify(r,forceStringifyErrors,"	"),5)}
				`}`),__publicField$d(this,"version",version),__publicField$d(this,"repo",repository),__publicField$d(this,"type"),__publicField$d(this,"info"),this.type=t,this.info=r}}function forceStringifyErrors(e,t){return t instanceof Error?Object.fromEntries(Object.getOwnPropertyNames(t).map(r=>[r,r==="stack"?t[r].split(/\n/):t[r]])):t}var ERROR_CODES=(e=>(e.PARSER_POSITION_ERROR="PARSER.POSITION",e.PARSER_CONFLICTING_OPTIONS_ERROR="PARSER.OPTIONS.CONFLICTING",e.PARSER_OPTION_REQUIRED_ERROR="PARSER.OPTIONS.CUSTOM_REQUIRED",e))(ERROR_CODES||{}),__defProp$c=Object.defineProperty,__defNormalProp$c=(e,t,r)=>t in e?__defProp$c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$c=(e,t,r)=>(__defNormalProp$c(e,typeof t!="symbol"?t+"":t,r),r);class Node{constructor(t,r,o){if(__publicField$c(this,"type"),__publicField$c(this,"start"),__publicField$c(this,"end"),__publicField$c(this,"valid"),this.type=t,r===void 0||o===void 0)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_POSITION_ERROR,{start:r,end:o});this.start=r,this.end=o}get parent(){}}var __defProp$b=Object.defineProperty,__defNormalProp$b=(e,t,r)=>t in e?__defProp$b(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$b=(e,t,r)=>(__defNormalProp$b(e,typeof t!="symbol"?t+"":t,r),r);class Token{constructor(t,r){if(__publicField$b(this,"type"),__publicField$b(this,"value"),__publicField$b(this,"expected"),__publicField$b(this,"start"),__publicField$b(this,"end"),t===void 0||r===void 0)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_POSITION_ERROR,{start:t,end:r});this.start=t,this.end=r}get parent(){}}var __defProp$a=Object.defineProperty,__defNormalProp$a=(e,t,r)=>t in e?__defProp$a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$a=(e,t,r)=>(__defNormalProp$a(e,typeof t!="symbol"?t+"":t,r),r),__accessCheck$6=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},__privateGet$6=(e,t,r)=>(__accessCheck$6(e,t,"read from private field"),r?r.call(e):t.get(e)),__privateAdd$6=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},__privateSet$6=(e,t,r,o)=>(__accessCheck$6(e,t,"write to private field"),o?o.call(e,r):t.set(e,r),r),_parent$6;class ValidToken extends Token{constructor({type:t,value:r,start:o,end:i}){super(o,i),__publicField$a(this,"type"),__publicField$a(this,"value"),__privateAdd$6(this,_parent$6,void 0),this.type=t,this.value=r}get parent(){return __privateGet$6(this,_parent$6)}set parent(t){if(__privateGet$6(this,_parent$6))throw new Error("parent property is readonly");__privateSet$6(this,_parent$6,t)}}_parent$6=new WeakMap;var TOKEN_TYPE=(e=>(e.VALUE="VALUE",e.AND="AND",e.OR="OR",e.NOT="NOT",e.BACKTICK="BACKTICK",e.SINGLEQUOTE="SINGLEQUOTE",e.DOUBLEQUOTE="DOUBLEQUOTE",e.PARENL="PARENL",e.PARENR="PARENR",e.BRACKETL="BRACKETL",e.BRACKETR="BRACKETR",e.OP_EXPANDED_SEP="OP_EXPANDED",e.OP_CUSTOM="OP_CUSTOM",e.REGEX="REGEX",e))(TOKEN_TYPE||{}),AST_TYPE=(e=>(e.EXPRESSION="EXPRESSION",e.GROUP="GROUP",e.ARRAY="ARRAY",e.CONDITION="CONDITION",e.VARIABLE="VARIABLE",e))(AST_TYPE||{}),__defProp$9=Object.defineProperty,__defNormalProp$9=(e,t,r)=>t in e?__defProp$9(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$9=(e,t,r)=>(__defNormalProp$9(e,typeof t!="symbol"?t+"":t,r),r),__accessCheck$5=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},__privateGet$5=(e,t,r)=>(__accessCheck$5(e,t,"read from private field"),r?r.call(e):t.get(e)),__privateAdd$5=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},__privateSet$5=(e,t,r,o)=>(__accessCheck$5(e,t,"write to private field"),o?o.call(e,r):t.set(e,r),r),_parent$5,_setParent$4;class ArrayNode extends Node{constructor({values:t,bracket:r,start:o,end:i}){super(AST_TYPE.ARRAY,o,i),__publicField$9(this,"values"),__publicField$9(this,"bracket"),__privateAdd$5(this,_parent$5,void 0),__privateAdd$5(this,_setParent$4,!1),this.values=t,this.bracket=r,this.valid=this.values.every(n=>n.valid)&&this.bracket.left instanceof ValidToken&&this.bracket.right instanceof ValidToken}get parent(){return __privateGet$5(this,_parent$5)}set parent(t){if(__privateGet$5(this,_setParent$4))throw new Error("parent property is readonly");__privateSet$5(this,_parent$5,t),__privateSet$5(this,_setParent$4,!0)}}_parent$5=new WeakMap;_setParent$4=new WeakMap;var __defProp$8=Object.defineProperty,__defNormalProp$8=(e,t,r)=>t in e?__defProp$8(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$8=(e,t,r)=>(__defNormalProp$8(e,typeof t!="symbol"?t+"":t,r),r);class Condition{constructor({property:t,operator:r,value:o,negate:i}){__publicField$8(this,"value"),__publicField$8(this,"operator"),__publicField$8(this,"property"),__publicField$8(this,"negate"),this.value=o,this.operator=r,this.property=t,this.negate=i}}var __defProp$7=Object.defineProperty,__defNormalProp$7=(e,t,r)=>t in e?__defProp$7(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$7=(e,t,r)=>(__defNormalProp$7(e,typeof t!="symbol"?t+"":t,r),r),__accessCheck$4=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},__privateGet$4=(e,t,r)=>(__accessCheck$4(e,t,"read from private field"),r?r.call(e):t.get(e)),__privateAdd$4=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},__privateSet$4=(e,t,r,o)=>(__accessCheck$4(e,t,"write to private field"),o?o.call(e,r):t.set(e,r),r),_parent$4,_setParent$3;class VariableNode extends Node{constructor({prefix:t,value:r,quote:o,start:i,end:n}){super(AST_TYPE.VARIABLE,i,n),__publicField$7(this,"value"),__publicField$7(this,"prefix"),__publicField$7(this,"quote"),__privateAdd$4(this,_parent$4,void 0),__privateAdd$4(this,_setParent$3,!1),this.prefix=t,this.value=r,this.quote=o,this.valid=this.value instanceof ValidToken&&(this.quote===void 0||this.quote.left instanceof ValidToken&&this.quote.right instanceof ValidToken)}get parent(){return __privateGet$4(this,_parent$4)}set parent(t){if(__privateGet$4(this,_setParent$3))throw new Error("parent property is readonly");__privateSet$4(this,_parent$4,t),__privateSet$4(this,_setParent$3,!0)}}_parent$4=new WeakMap;_setParent$3=new WeakMap;var __defProp$6=Object.defineProperty,__defNormalProp$6=(e,t,r)=>t in e?__defProp$6(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$6=(e,t,r)=>(__defNormalProp$6(e,typeof t!="symbol"?t+"":t,r),r),__accessCheck$3=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},__privateGet$3=(e,t,r)=>(__accessCheck$3(e,t,"read from private field"),r?r.call(e):t.get(e)),__privateAdd$3=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},__privateSet$3=(e,t,r,o)=>(__accessCheck$3(e,t,"write to private field"),o?o.call(e,r):t.set(e,r),r),_parent$3,_setParent$2;class ConditionNode extends Node{constructor({property:t,propertyOperator:r,sep:o,value:i,start:n,end:s,operator:a}){var l,p;super(AST_TYPE.CONDITION,n,s),__publicField$6(this,"value"),__publicField$6(this,"operator"),__publicField$6(this,"property"),__publicField$6(this,"propertyOperator"),__publicField$6(this,"sep"),__privateAdd$3(this,_parent$3,void 0),__privateAdd$3(this,_setParent$2,!1),this.value=i,this.operator=a,this.property=t,this.propertyOperator=r,this.sep=o,this.operator=a,this.valid=(this.operator===void 0||this.operator instanceof ValidToken)&&this.value instanceof Node&&this.value.valid&&(this.property===void 0&&this.propertyOperator===void 0&&this.sep===void 0||this.property instanceof VariableNode&&(this.propertyOperator instanceof ValidToken||((l=this.sep)==null?void 0:l.left)instanceof ValidToken&&(this.sep.right===void 0||((p=this.sep)==null?void 0:p.right)instanceof ValidToken)))}get parent(){return __privateGet$3(this,_parent$3)}set parent(t){if(__privateGet$3(this,_setParent$2))throw new Error("parent property is readonly");__privateSet$3(this,_parent$3,t),__privateSet$3(this,_setParent$2,!0)}}_parent$3=new WeakMap;_setParent$2=new WeakMap;var __defProp$5=Object.defineProperty,__defNormalProp$5=(e,t,r)=>t in e?__defProp$5(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$5=(e,t,r)=>(__defNormalProp$5(e,typeof t!="symbol"?t+"":t,r),r),__accessCheck$2=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},__privateGet$2=(e,t,r)=>(__accessCheck$2(e,t,"read from private field"),r?r.call(e):t.get(e)),__privateAdd$2=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},__privateSet$2=(e,t,r,o)=>(__accessCheck$2(e,t,"write to private field"),o?o.call(e,r):t.set(e,r),r),_parent$2;class ErrorToken extends Token{constructor({expected:t,start:r,end:o}){super(r,o),__publicField$5(this,"expected"),__privateAdd$2(this,_parent$2,void 0),this.expected=t}get parent(){return __privateGet$2(this,_parent$2)}set parent(t){if(__privateGet$2(this,_parent$2))throw new Error("parent property is readonly");__privateSet$2(this,_parent$2,t)}}_parent$2=new WeakMap;var __defProp$4=Object.defineProperty,__defNormalProp$4=(e,t,r)=>t in e?__defProp$4(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$4=(e,t,r)=>(__defNormalProp$4(e,typeof t!="symbol"?t+"":t,r),r);class Expression{constructor({operator:t,left:r,right:o}){__publicField$4(this,"left"),__publicField$4(this,"right"),__publicField$4(this,"operator"),this.operator=t,this.right=o,this.left=r}}var __defProp$3=Object.defineProperty,__defNormalProp$3=(e,t,r)=>t in e?__defProp$3(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$3=(e,t,r)=>(__defNormalProp$3(e,typeof t!="symbol"?t+"":t,r),r),__accessCheck$1=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},__privateGet$1=(e,t,r)=>(__accessCheck$1(e,t,"read from private field"),r?r.call(e):t.get(e)),__privateAdd$1=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},__privateSet$1=(e,t,r,o)=>(__accessCheck$1(e,t,"write to private field"),o?o.call(e,r):t.set(e,r),r),_parent$1,_setParent$1;class ExpressionNode extends Node{constructor({operator:t,left:r,right:o,start:i,end:n}){super(AST_TYPE.EXPRESSION,i,n),__publicField$3(this,"operator"),__publicField$3(this,"left"),__publicField$3(this,"right"),__privateAdd$1(this,_parent$1,void 0),__privateAdd$1(this,_setParent$1,!1),this.operator=t,this.right=o,this.left=r,this.valid=this.operator instanceof ValidToken&&this.left instanceof Node&&this.left.valid&&this.right instanceof Node&&this.right.valid}get parent(){return __privateGet$1(this,_parent$1)}set parent(t){if(__privateGet$1(this,_setParent$1))throw new Error("parent property is readonly");__privateSet$1(this,_parent$1,t),__privateSet$1(this,_setParent$1,!0)}}_parent$1=new WeakMap;_setParent$1=new WeakMap;var __defProp$2=Object.defineProperty,__defNormalProp$2=(e,t,r)=>t in e?__defProp$2(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$2=(e,t,r)=>(__defNormalProp$2(e,typeof t!="symbol"?t+"":t,r),r),__accessCheck=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},__privateGet=(e,t,r)=>(__accessCheck(e,t,"read from private field"),r?r.call(e):t.get(e)),__privateAdd=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},__privateSet=(e,t,r,o)=>(__accessCheck(e,t,"write to private field"),o?o.call(e,r):t.set(e,r),r),_parent,_setParent;class GroupNode extends Node{constructor({prefix:t,expression:r,paren:o,start:i,end:n}){super(AST_TYPE.GROUP,i,n),__publicField$2(this,"prefix"),__publicField$2(this,"expression"),__publicField$2(this,"paren"),__privateAdd(this,_parent,void 0),__privateAdd(this,_setParent,!1),this.prefix=t,this.expression=r,this.paren=o,this.valid=(this.prefix===void 0||this.prefix instanceof ValidToken||this.prefix instanceof Node&&this.prefix.valid)&&this.expression instanceof Node&&this.expression.valid&&(this.paren===void 0||this.paren.left instanceof ValidToken&&this.paren.right instanceof ValidToken)}get parent(){return __privateGet(this,_parent)}set parent(t){if(__privateGet(this,_setParent))throw new Error("parent property is readonly");__privateSet(this,_parent,t),__privateSet(this,_setParent,!0)}}_parent=new WeakMap;_setParent=new WeakMap;function get(e,t){let r=e;for(const o of t)if(r[o]!==void 0)r=r[o];else return;return t.length>0?r:void 0}function insert(e,t,r){r=typeof r=="number"?[r,r]:r;const o=[...r];if(r[0]<0){let i=t.length+r[0];i<0&&(i=0),r[0]=i}if(r[1]<0){let i=t.length+r[1];i<0&&(i=0),r[1]=i}if(r[0]>r[1]){const i=`${o[0]}${o[0]<0?` (normalized to ${r[0]})`:""}`,n=`${o[1]}${o[1]<0?` (normalized to ${r[1]})`:""}`,s=new Error(`Range start ${i} cannot come after range end ${n}`);throw s.range=o,s}return t.slice(0,r[0])+e+t.slice(r[1],t.length)}function isArray(e){return Array.isArray(e)}function isWhitespace(e){return e.trim().length===0}function setReadOnly(e,t,r){e[t]=r}function unreachable(e="This error should never happen, please file a bug report."){throw new Error(e)}function isFullPos(e){return typeof e=="object"&&e.start!==void 0&&e.end!==void 0}function pos(e,t){if(typeof e=="number")return{start:e,end:t};{const r=e;if(r===void 0)return{};const o=typeof t=="object"?t.fill:!1;if(isFullPos(r))return{start:r.start,end:r.end};if(o){let i=r.start,n=r.end;return i!==void 0&&n===void 0&&(n=i),n!==void 0&&i===void 0&&(i=n),{start:i,end:n}}return{}}}function error(e,t){if(e===void 0)throw new Error("should never happen, passed undefined position for error token");return new ErrorToken({expected:t,start:e,end:e})}const operators=e=>(t,r)=>new ValidToken({value:t,type:e,...r}),delimiters=e=>(t,r)=>t?new ValidToken({value:t,type:e,...r}):void 0,maybeToken=e=>(t,r)=>t===void 0?error(r.end,[e]):new ValidToken({value:t,type:e,...r}),token={value:maybeToken(TOKEN_TYPE.VALUE),custom:maybeToken(TOKEN_TYPE.OP_CUSTOM),sep:maybeToken(TOKEN_TYPE.OP_EXPANDED_SEP)},delimiter={parenL:delimiters(TOKEN_TYPE.PARENL),parenR:delimiters(TOKEN_TYPE.PARENR),bracketL:delimiters(TOKEN_TYPE.BRACKETL),bracketR:delimiters(TOKEN_TYPE.BRACKETR),double:delimiters(TOKEN_TYPE.DOUBLEQUOTE),single:delimiters(TOKEN_TYPE.SINGLEQUOTE),regex:delimiters(TOKEN_TYPE.REGEX),tick:delimiters(TOKEN_TYPE.BACKTICK),tokenError:error},operator={and:operators(TOKEN_TYPE.AND),or:operators(TOKEN_TYPE.OR),not:operators(TOKEN_TYPE.NOT)};function variable(e,t,r,o,i){var n;const s={prefix:e??void 0,value:r??error((e==null?void 0:e.end)??(t==null?void 0:t.end)??(o==null?void 0:o.start),[TOKEN_TYPE.VALUE]),start:(e==null?void 0:e.start)??(t==null?void 0:t.start)??(r==null?void 0:r.start)??(o==null?void 0:o.start),end:(o==null?void 0:o.end)??(r==null?void 0:r.end)??(t==null?void 0:t.end)??(e==null?void 0:e.end)};return(t||o)&&(s.quote={left:t??error(s.value.start,[o.type]),right:o??error(s.value.end,[t.type])},i&&(s.quote.flags=i,s.end=(n=s.quote)==null?void 0:n.flags.end)),new VariableNode(s)}function condition(e,t,{propertyOperator:r,sepL:o,sepR:i}={},n){var s;const a=(e==null?void 0:e.start)??(t==null?void 0:t.start)??(o==null?void 0:o.start)??(r==null?void 0:r.start)??(i==null?void 0:i.start)??(n==null?void 0:n.start),l=(n==null?void 0:n.end)??(i==null?void 0:i.end)??(r==null?void 0:r.end)??(o==null?void 0:o.end)??(t==null?void 0:t.end)??(e==null?void 0:e.end),p={value:n||error(l,[TOKEN_TYPE.VALUE]),start:a,end:l};return e&&(p.operator=e),t&&(p.property=t),r&&(p.propertyOperator=r),o||i?(p.sep={},o&&(p.sep.left=o,p.property||(p.property=error(o.start,[TOKEN_TYPE.VALUE])),p.propertyOperator||(p.propertyOperator=error((o==null?void 0:o.end)??(i==null?void 0:i.start),[TOKEN_TYPE.VALUE]))),i?p.sep.right=i:(!p.value||p.value instanceof VariableNode)&&(p.sep.right=error(((s=p.value)==null?void 0:s.start)??l,[TOKEN_TYPE.OP_EXPANDED_SEP]))):r&&(p.property||(p.property=error(r.start,[TOKEN_TYPE.VALUE]))),new ConditionNode(p)}function expression(e,t,r){return new ExpressionNode({left:e??error((t==null?void 0:t.start)??(r==null?void 0:r.start),[TOKEN_TYPE.VALUE]),operator:t??error((e==null?void 0:e.end)??(r==null?void 0:r.start),[TOKEN_TYPE.AND,TOKEN_TYPE.OR]),right:r??error((t==null?void 0:t.end)??(e==null?void 0:e.end),[TOKEN_TYPE.VALUE]),start:(e==null?void 0:e.start)??(t==null?void 0:t.start)??(r==null?void 0:r.start),end:(r==null?void 0:r.end)??(t==null?void 0:t.end)??(e==null?void 0:e.end)})}function group(e,t,r,o,i){const n={prefix:t??e??void 0,expression:o??error((r==null?void 0:r.end)??(i==null?void 0:i.start),[TOKEN_TYPE.VALUE]),paren:{left:r??error((t==null?void 0:t.end)??(e==null?void 0:e.end)??(o==null?void 0:o.start)??(i==null?void 0:i.start),[TOKEN_TYPE.PARENL]),right:i??error((o==null?void 0:o.end)??(r==null?void 0:r.end),[TOKEN_TYPE.PARENR])},start:(t==null?void 0:t.start)??(e==null?void 0:e.start)??(r==null?void 0:r.start)??(o==null?void 0:o.start)??(i==null?void 0:i.start),end:(i==null?void 0:i.end)??(o==null?void 0:o.end)??(r==null?void 0:r.end)??(e==null?void 0:e.end)??(t==null?void 0:t.end)};return new GroupNode(n)}function array(e,t,r){var o,i;const n={values:t,bracket:{left:e,right:r??error(((o=t[t.length-1])==null?void 0:o.end)??(e==null?void 0:e.end),[TOKEN_TYPE.BRACKETR])},start:e.start,end:(r==null?void 0:r.end)??((i=t[t.length-1])==null?void 0:i.end)??e.end};return new ArrayNode(n)}function applyBoolean(e,t){return e===void 0||e?t:t?e:!0}function applyPrefix(e,t,r){return e===void 0?t:r(e,t)}function isBlank(e){return e.length===0}function pushIfNotIn(e,...t){for(const r of t)if(isArray(r))for(const o of r)e.includes(o)||e.push(o);return e}const defaultConditionNormalizer=function({value:t,operator:r,isNegated:o}){return{value:t,operator:r,negate:o}},defaultValueComparer=function(t,r){return r===t.value};function checkParserOpts(e,t=!1,r=!1){var o,i,n,s,a,l,p,_,E;if(!t){const d=[...e.keywords.and,...e.keywords.or,...e.keywords.not].map(T=>T.value),h=e.keywords.not.filter(T=>T.isSymbol).map(T=>T.value),y=[...[...d].filter(T=>!h.includes(T)),"(",")",...e.arrayValues?["[","]"]:[],...e.regexValues?["/"]:[]],u=[];if(e.expandedPropertySeparator&&u.push(e.expandedPropertySeparator),e.customPropertyOperators&&pushIfNotIn(u,e.customPropertyOperators),e.expandedPropertySeparator&&isBlank(e.expandedPropertySeparator))throw new BooleanParserLibraryError(ERROR_CODES.PARSER_CONFLICTING_OPTIONS_ERROR,{prohibited:[""],invalid:e.expandedPropertySeparator},"expandedPropertySeparator cannot be blank");const c=(o=e.customPropertyOperators)==null?void 0:o.find(T=>isBlank(T));if(c!==void 0)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_CONFLICTING_OPTIONS_ERROR,{prohibited:[""],invalid:c},"customPropertyOperators cannot contain blank entries");const v=(i=e.prefixableStrings)==null?void 0:i.find(T=>isBlank(T));if(v!==void 0)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_CONFLICTING_OPTIONS_ERROR,{prohibited:[""],invalid:v},"prefixableStrings cannot contain blank entries");for(const T of["and","or","not"]){const S=(s=(n=e.keywords[T])==null?void 0:n.find(b=>isBlank(b.value)))==null?void 0:s.value;if(S!==void 0)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_CONFLICTING_OPTIONS_ERROR,{prohibited:[""],invalid:S},`keywords.${T} cannot contain entries with blank values`)}const O=[...y,...h,...u],g=[...y,...h],R="cannot contain operators or special symbols, but found",N="cannot contain boolean operators or special symbols, but found",P=(a=e.prefixableStrings)==null?void 0:a.find(T=>O.includes(T));if(P)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_CONFLICTING_OPTIONS_ERROR,{prohibited:O,invalid:P},`prefixableStrings ${R} "${P}"`);const A=g.find(T=>T===e.expandedPropertySeparator);if(A)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_CONFLICTING_OPTIONS_ERROR,{prohibited:g,invalid:A},`expandedPropertySeparator ${N} "${A}"`);const m=(l=e.customPropertyOperators)!=null&&l.find(T=>y.includes(T))?e.expandedPropertySeparator:void 0;if(m)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_CONFLICTING_OPTIONS_ERROR,{prohibited:y,invalid:m},`customPropertyOperator ${N} "${m}"`)}if(t){const d=[];if((((p=e.prefixableStrings)==null?void 0:p.length)??0)>0&&d.push("prefixableStrings"),(((_=e.customPropertyOperators)==null?void 0:_.length)??0)>0&&d.push("customPropertyOperators"),(((E=e.expandedPropertySeparator)==null?void 0:E.length)??0)>0&&d.push("expandedPropertySeparator"),e.regexValues&&d.push("regexValues"),d.length>0&&e.conditionNormalizer===defaultConditionNormalizer)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_OPTION_REQUIRED_ERROR,{options:d,requires:"conditionNormalizer"},`A custom conditionNormalizer function must be specified when using the following options: ${d.join(", ")}`);const h=[];if(e.regexValues&&h.push("regexValues"),e.regexValues&&h.push("arrayValues"),h.length>0&&e.valueComparer===defaultValueComparer)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_OPTION_REQUIRED_ERROR,{options:h,requires:"valueComparer"},`A custom valueComparer function must be specified when using the following options: ${h.join(", ")}`)}if(r&&e.valueValidator===void 0)throw new BooleanParserLibraryError(ERROR_CODES.PARSER_OPTION_REQUIRED_ERROR,{requires:"valueValidator"},"A custom valueValidator function must be specified when using the validate method.")}function extractPosition(e,t){return{start:e.startOffset-(t??0),end:e.endOffset+1-(t??0)}}const defaultKeyParser=function(t){return t===void 0?[]:[t]},defaultPrefixApplier=function(t,r){return t+r};function parseParserOptions(e){var t,r,o;return{prefixApplier:defaultPrefixApplier,keyParser:defaultKeyParser,valueComparer:defaultValueComparer,conditionNormalizer:defaultConditionNormalizer,prefixableGroups:!0,prefixableStrings:void 0,expandedPropertySeparator:void 0,customPropertyOperators:void 0,onMissingBooleanOperator:"error",arrayValues:!0,regexValues:!0,...e,keywords:{or:(t=e.keywords)!=null&&t.or?e.keywords.or:[{value:"||",isSymbol:!0},{value:"|",isSymbol:!0},{value:"or",isSymbol:!1},{value:"OR",isSymbol:!1}],and:(r=e.keywords)!=null&&r.and?e.keywords.and:[{value:"&&",isSymbol:!0},{value:"&",isSymbol:!0},{value:"and",isSymbol:!1},{value:"AND",isSymbol:!1}],not:(o=e.keywords)!=null&&o.not?e.keywords.not:[{value:"!",isSymbol:!0},{value:"not",isSymbol:!1},{value:"NOT",isSymbol:!1}]}}}var __defProp$1=Object.defineProperty,__defNormalProp$1=(e,t,r)=>t in e?__defProp$1(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField$1=(e,t,r)=>(__defNormalProp$1(e,typeof t!="symbol"?t+"":t,r),r);const regexFlags=/^[a-zA-Z]+/,BRACKET_PREFIX="BRACKET";var $T=(e=>(e._="_",e.VALUE_UNQUOTED="VALUE_UNQUOTED",e.VALUE_REGEX="VALUE_REGEX",e.VALUE_NOT_SINGLE="VALUE_NOT_SINGLE",e.VALUE_NOT_DOUBLE="VALUE_NOT_DOUBLE",e.VALUE_NOT_BACKTICK="VALUE_NOT_BACKTICK",e.SYM_OR="SYM_OR",e.SYM_AND="SYM_AND",e.SYM_NOT="SYM_NOT",e.WORD_OR="WORD_OR",e.WORD_AND="WORD_AND",e.WORD_NOT="WORD_NOT",e.REGEX_START="REGEX_START",e.REGEX_END="REGEX_END",e.EXP_PROP_OP="EXP_PROP_OP",e.CUSTOM_PROP_OP="CUSTOM_PROP_OP",e.PAREN_L="PAREN_L",e.PAREN_R="PAREN_R",e.BRACKET_L="BRACKET_L",e.BRACKET_R="BRACKET_R",e.QUOTE_SINGLE="QUOTE_SINGLE",e.QUOTE_DOUBLE="QUOTE_DOUBLE",e.QUOTE_BACKTICK="QUOTE_BACKTICK",e))($T||{}),$C=(e=>(e.ANY="ANY",e.QUOTE_ANY="QUOTE_ANY",e.REGEX_ANY="REGEX_ANY",e.VALUE_FOR_SINGLE="VALUE_FOR_SINGLE",e.VALUE_FOR_DOUBLE="VALUE_FOR_DOUBLE",e.VALUE_FOR_BACKTICK="VALUE_FOR_BACKTICK",e.OPERATOR_OR="OPERATOR_OR",e.OPERATOR_AND="OPERATOR_AND",e.OPERATOR_NOT="OPERATOR_NOT",e.VALUE="VALUE",e))($C||{});function createTokenCategoryType(e,t){return{type:e,isCategory:!0,entries:Object.fromEntries(t.filter(r=>r!==void 0).map(r=>[r.type,r]))}}function createTokenType(e,t){return{type:e,...t}}function matchWhileCharNotEqualToUnescaped(e){return(t,r,o)=>{let i=o;for(;t!==void 0&&t!==e;){if(t==="\\"){i+=2,t=r[i];continue}i++,t=r[i]}return o===i?!1:r.slice(o,i)}}function matchSymbol(e){return(t,r,o)=>{for(const i of e){const n=r.slice(o,o+i.length);if(n===i)return n}return!1}}class Lexer{constructor(t={}){__publicField$1(this,"symbols"),__publicField$1(this,"$"),__publicField$1(this,"$categories"),__publicField$1(this,"branches"),__publicField$1(this,"opts"),this.opts=parseParserOptions(t),checkParserOpts(this.opts),this.symbols=this.calculateSymbolInfo();const r=this.createTokens();this.$=r.$,this.$categories=r.$categories,this.branches=this.createModeBranches()}calculateSymbolInfo(){var t;const r=this.opts,o=r.keywords.or.filter(u=>u.isSymbol).map(u=>u.value),i=r.keywords.and.filter(u=>u.isSymbol).map(u=>u.value),n=r.keywords.not.filter(u=>u.isSymbol).map(u=>u.value),s=r.keywords.or.filter(u=>!u.isSymbol).map(u=>u.value),a=r.keywords.and.filter(u=>!u.isSymbol).map(u=>u.value),l=r.keywords.not.filter(u=>!u.isSymbol).map(u=>u.value),p=[...o,...i,...n],_=r.customPropertyOperators??[],E=r.expandedPropertySeparator??"";E&&p.push(E),_.length>0&&pushIfNotIn(p,_),r.regexValues&&p.push("\\/"),r.arrayValues&&p.push("\\[");const d={symOrs:o.sort((u,c)=>c.length-u.length),symAnds:i.sort((u,c)=>c.length-u.length),symNots:n.sort((u,c)=>c.length-u.length),wordOrs:s.sort((u,c)=>c.length-u.length),wordAnds:a.sort((u,c)=>c.length-u.length),wordNots:l.sort((u,c)=>c.length-u.length),all:p.sort((u,c)=>c.length-u.length)},h=((t=r.customPropertyOperators)==null?void 0:t.includes(r.expandedPropertySeparator))??!1;let y=!1;if(d.symNots.length>0){for(const u of r.customPropertyOperators??[])for(const c of d.symNots)if(u===c){y=!0;break}}return{...d,expandedSepAlsoCustom:h,customOpAlsoNegation:y}}createTokens(){var t;const r=this.opts,o=this.symbols,i={_:createTokenType("_",{skip:!0,matches:(s,a,l)=>{let p=l;for(;s===" "||s==="	"||s===`
`||s==="\r"||s==="\v"||s==="\f";)p++,s=a[p];return l===p?!1:a.slice(l,p)}}),REGEX_START:createTokenType("REGEX_START",{push:"NOT_REGEX",matches:s=>s==="/"}),REGEX_END:createTokenType("REGEX_END",{push:"MAIN",matches:(s,a,l)=>{let p=l;if(s==="/"){p++,s=a[p];const _=regexFlags.exec(a.slice(p));return _!==null&&(p+=_.input.length),a.slice(l,p)}else return!1}}),VALUE_REGEX:createTokenType("VALUE_REGEX",{push:"REGEX_END",matches:(s,a,l)=>{let p=l,_=0,E=!1;for(;s!==void 0&&(s!=="/"||_>0||E);)s==="["&&_++,s==="]"&&_>0&&_--,s==="\\"?E?E=!1:E=!0:E&&(E=!1),p++,s=a[p];return l===p?!1:a.slice(l,p)}}),QUOTE_SINGLE:createTokenType("QUOTE_SINGLE",{push:(s,a)=>{const l=a[a.length-2];if((l==null?void 0:l.type)==="VALUE_NOT_SINGLE"||(l==null?void 0:l.type)==="VALUE_UNQUOTED")return"MAIN";switch(s){case"BRACKET_MAIN":return"BRACKET_NOT_SINGLE";case"MAIN":return"NOT_SINGLE";default:return s.startsWith(BRACKET_PREFIX)?"BRACKET_MAIN":"MAIN"}},matches:s=>s==="'"}),QUOTE_DOUBLE:createTokenType("QUOTE_DOUBLE",{push:(s,a)=>{const l=a[a.length-2];if((l==null?void 0:l.type)==="VALUE_NOT_DOUBLE"||(l==null?void 0:l.type)==="VALUE_UNQUOTED")return s.startsWith(BRACKET_PREFIX)?"BRACKET_MAIN":"MAIN";switch(s){case"BRACKET_MAIN":return"BRACKET_NOT_DOUBLE";case"MAIN":return"NOT_DOUBLE";default:return s.startsWith(BRACKET_PREFIX)?"BRACKET_MAIN":"MAIN"}},matches:s=>s==='"'}),QUOTE_BACKTICK:createTokenType("QUOTE_BACKTICK",{push:(s,a)=>{const l=a[a.length-2];if((l==null?void 0:l.type)==="VALUE_NOT_BACKTICK"||(l==null?void 0:l.type)==="VALUE_UNQUOTED")return"MAIN";switch(s){case"BRACKET_MAIN":return"BRACKET_NOT_BACKTICK";case"MAIN":return"NOT_BACKTICK";default:return s.startsWith(BRACKET_PREFIX)?"BRACKET_MAIN":"MAIN"}},matches:s=>s==="`"}),VALUE_NOT_SINGLE:createTokenType("VALUE_NOT_SINGLE",{push:s=>s.startsWith(BRACKET_PREFIX)?"BRACKET_MAIN":"MAIN",matches:matchWhileCharNotEqualToUnescaped("'")}),VALUE_NOT_DOUBLE:createTokenType("VALUE_NOT_DOUBLE",{push:s=>s.startsWith(BRACKET_PREFIX)?"BRACKET_MAIN":"MAIN",matches:matchWhileCharNotEqualToUnescaped('"')}),VALUE_NOT_BACKTICK:createTokenType("VALUE_NOT_BACKTICK",{push:s=>s.startsWith(BRACKET_PREFIX)?"BRACKET_MAIN":"MAIN",matches:matchWhileCharNotEqualToUnescaped("`")}),VALUE_UNQUOTED:createTokenType("VALUE_UNQUOTED",{push:s=>s.startsWith(BRACKET_PREFIX)?"BRACKET_MAIN":"MAIN",matches:(s,a,l,p)=>{let _=l;for(;s!==void 0;){if(s==="\\"){_+=2,s=a[_];continue}if(p==="MAIN"){let E=!1;for(const d of o.all)if(a.slice(_,_+d.length)===d){E=!0;break}if(E)break}if(s===" "||s==="	"||s==="("||s===")"||s==="'"||s==='"'||s==="`"||s==="\\"||p==="BRACKET_MAIN"&&s==="]")break;_++,s=a[_]}return l===_?!1:a.slice(l,_)}}),...o.symOrs.length>0?{SYM_OR:createTokenType("SYM_OR",{matches:matchSymbol(o.symOrs)})}:{},...o.symAnds.length>0?{SYM_AND:createTokenType("SYM_AND",{matches:matchSymbol(o.symAnds)})}:{},...o.symNots.length>0?{SYM_NOT:createTokenType("SYM_NOT",{matches:matchSymbol(o.symNots)})}:{},...o.wordOrs.length>0?{WORD_OR:createTokenType("WORD_OR",{matches:matchSymbol(o.wordOrs),longerAlt:"VALUE_UNQUOTED"})}:{},...o.wordAnds.length>0?{WORD_AND:createTokenType("WORD_AND",{matches:matchSymbol(o.wordAnds),longerAlt:"VALUE_UNQUOTED"})}:{},...o.wordNots.length>0?{WORD_NOT:createTokenType("WORD_NOT",{matches:matchSymbol(o.wordNots),longerAlt:"VALUE_UNQUOTED"})}:{},...isBlank(r.expandedPropertySeparator??"")?{}:{EXP_PROP_OP:createTokenType("EXP_PROP_OP",{matches:(s,a,l)=>{for(const p of r.expandedPropertySeparator)if(a.slice(l,l+p.length)===p)return p;return!1}})},...(((t=r.customPropertyOperators)==null?void 0:t.length)??0)>0&&!o.customOpAlsoNegation?{CUSTOM_PROP_OP:createTokenType("CUSTOM_PROP_OP",{matches:(s,a,l)=>{for(const p of r.customPropertyOperators??[])if(a.slice(l,l+p.length)===p)return p;return!1}})}:{},PAREN_L:createTokenType("PAREN_L",{matches:s=>s==="("}),PAREN_R:createTokenType("PAREN_R",{matches:s=>s===")"}),BRACKET_L:createTokenType("BRACKET_L",{push:"BRACKET_MAIN",matches:s=>s==="["}),BRACKET_R:createTokenType("BRACKET_R",{push:"MAIN",matches:s=>s==="]"})},n={ANY:createTokenCategoryType("ANY",[i.REGEX_START,i.REGEX_END,i.QUOTE_SINGLE,i.QUOTE_DOUBLE,i.QUOTE_BACKTICK,i.VALUE_NOT_SINGLE,i.VALUE_NOT_DOUBLE,i.VALUE_NOT_BACKTICK,i.VALUE_UNQUOTED,i.SYM_OR,i.SYM_AND,i.SYM_NOT,i.WORD_OR,i.WORD_AND,i.WORD_NOT,i.EXP_PROP_OP,i.CUSTOM_PROP_OP,i.PAREN_L,i.PAREN_R,i.BRACKET_L,i.BRACKET_R]),VALUE:createTokenCategoryType("VALUE",[i.VALUE_UNQUOTED,i.VALUE_NOT_SINGLE,i.VALUE_NOT_DOUBLE,i.VALUE_NOT_BACKTICK]),VALUE_FOR_SINGLE:createTokenCategoryType("VALUE_FOR_SINGLE",[i.VALUE_NOT_SINGLE]),VALUE_FOR_DOUBLE:createTokenCategoryType("VALUE_FOR_DOUBLE",[i.VALUE_NOT_DOUBLE]),VALUE_FOR_BACKTICK:createTokenCategoryType("VALUE_FOR_BACKTICK",[i.VALUE_NOT_BACKTICK]),REGEX_ANY:createTokenCategoryType("REGEX_ANY",[i.REGEX_START,i.REGEX_END]),QUOTE_ANY:createTokenCategoryType("QUOTE_ANY",[i.QUOTE_SINGLE,i.QUOTE_DOUBLE,i.QUOTE_BACKTICK]),OPERATOR_OR:createTokenCategoryType("OPERATOR_OR",[i.SYM_OR,i.WORD_OR]),OPERATOR_AND:createTokenCategoryType("OPERATOR_AND",[i.SYM_AND,i.WORD_AND]),OPERATOR_NOT:createTokenCategoryType("OPERATOR_NOT",[i.SYM_NOT,i.WORD_NOT])};return{$:i,$categories:n}}createModeBranches(){const t=this.opts,r=this.$,o=[r.QUOTE_SINGLE,r.QUOTE_DOUBLE,r.QUOTE_BACKTICK],i=[r.PAREN_L,r.PAREN_R],n=[r.EXP_PROP_OP,r.CUSTOM_PROP_OP,r.SYM_OR,r.SYM_AND,r.SYM_NOT,r.WORD_OR,r.WORD_AND,r.WORD_NOT].filter(s=>s!==void 0);return{MAIN:[r._,...i,...t.arrayValues?[r.BRACKET_L]:[],...n,...o,...t.regexValues?[r.REGEX_START]:[],r.VALUE_UNQUOTED],MAYBE_QUOTE_ERROR:[...o,...t.regexValues?[r.REGEX_END]:[]],NOT_SINGLE:[r.VALUE_NOT_SINGLE,r.QUOTE_SINGLE],NOT_DOUBLE:[r.VALUE_NOT_DOUBLE,r.QUOTE_DOUBLE],NOT_BACKTICK:[r.VALUE_NOT_BACKTICK,r.QUOTE_BACKTICK],...t.regexValues?{NOT_REGEX:[r.VALUE_REGEX,r.REGEX_END],REGEX_END:[r.REGEX_END]}:{},...t.arrayValues?{BRACKET_MAIN:[r._,...o,r.BRACKET_R,r.VALUE_UNQUOTED],BRACKET_MAYBE_QUOTE_ERROR:[...o],BRACKET_NOT_SINGLE:[r.VALUE_NOT_SINGLE,r.QUOTE_SINGLE],BRACKET_NOT_DOUBLE:[r.VALUE_NOT_DOUBLE,r.QUOTE_DOUBLE],BRACKET_NOT_BACKTICK:[r.VALUE_NOT_BACKTICK,r.QUOTE_BACKTICK]}:{}}}tokenize(t){const r=this.createModeBranches(),o=[];let i="MAIN",n=0,s=t[n],a=r[i];for(;n<t.length;)for(const l of a){let p=l.matches(s,t,n,i);if(p){let _=p===!0?1:p.length,E=l.type;if(l.longerAlt){const u=this.$[l.longerAlt].matches(s,t,n,i),c=u===!0?1:u.length;u&&c>_&&(p=u,_=c,E=l.longerAlt)}const d=n+_,y=createToken(E,p===!0?s:p,n,d-1);l.skip||o.push(y),l.push&&(i=typeof l.push=="function"?l.push(i,o):l.push,a=r[i]),n=d,s=t[n];break}}return o}}function createToken(e,t,r,o){return{type:e,value:t,startOffset:r,endOffset:o}}function getUnclosedRightParenCount(e){let t=0,r=0;for(const o of e)o.type===$T.PAREN_R?t>0?t--:r++:o.type===$T.PAREN_L&&t++;return r}function assignParents(e){var t,r,o,i,n,s,a;if(e instanceof VariableNode)e.prefix&&(e.prefix.parent=e),(t=e.quote)!=null&&t.left&&(e.quote.left.parent=e),(r=e.quote)!=null&&r.right&&(e.quote.right.parent=e),(o=e.quote)!=null&&o.flags&&(e.quote.flags.parent=e),e.value.parent=e;else if(e instanceof ConditionNode)e.operator&&(e.operator.parent=e),e.property&&(e.property.parent=e,e.property instanceof Node&&assignParents(e.property)),e.propertyOperator&&(e.propertyOperator.parent=e),(i=e.sep)!=null&&i.left&&(e.sep.left.parent=e),(n=e.sep)!=null&&n.right&&(e.sep.right.parent=e),e.value.parent=e,e.value instanceof Node&&assignParents(e.value);else if(e instanceof ExpressionNode)e.operator&&(e.operator.parent=e),e.right.parent=e,e.right instanceof Node&&assignParents(e.right),e.left.parent=e,e.left instanceof Node&&assignParents(e.left);else if(e instanceof GroupNode)e.prefix&&(e.prefix.parent=e,e.prefix instanceof Node&&assignParents(e.prefix)),(s=e.paren)!=null&&s.left&&(e.paren.left.parent=e),(a=e.paren)!=null&&a.right&&(e.paren.right.parent=e),e.expression.parent=e,e.expression instanceof Node&&assignParents(e.expression);else if(e instanceof ArrayNode){e.bracket.left&&(e.bracket.left.parent=e),e.bracket.right&&(e.bracket.right.parent=e);for(const l of e.values)l.parent=e,assignParents(l)}}function seal(e){e instanceof Node&&assignParents(e),e.parent=void 0}var SUGGESTION_TYPE=(e=>(e.VARIABLE="VARIABLE",e.ARRAY_VALUE="ARRAY_VALUE",e.VALUE="VALUE",e.PREFIX="PREFIX",e.BOOLEAN_WORD_OP="BOOLEAN_WORD_OP",e.BOOLEAN_SYMBOL_OP="BOOLEAN_SYMBOL_OP",e.BACKTICK="BACKTICK",e.DOUBLEQUOTE="DOUBLEQUOTE",e.SINGLEQUOTE="SINGLEQUOTE",e.PARENL="PARENL",e.PARENR="PARENR",e.PROPERTY="PROPERTY",e.EXPANDED_PROPERTY_OPERATOR="EXPANDED_PROPERTY_OPERATOR",e.CUSTOM_PROPERTY_OPERATOR="CUSTOM_PROPERTY_OPERATOR",e.PROPERTY_SEP="PROPERTY_SEP",e.BRAKCETR="BRAKCETR",e.REGEX="REGEX",e.REGEX_FLAGS="REGEX_FLAGS",e))(SUGGESTION_TYPE||{});function extractTokens(e){var t,r,o;if(e instanceof ErrorToken)return[e];if(e instanceof VariableNode){const i=e.prefix?[e.prefix]:[],n=e.quote?[e.quote.right]:[],s=e.quote?[e.quote.left]:[],a=(t=e.quote)!=null&&t.flags?[e.quote.flags]:[];return[...i,...s,e.value,...n,...a]}if(e instanceof ConditionNode){const i=e.value instanceof Node?extractTokens(e.value):[e.value],n=e.operator?[e.operator]:[],s=e.property?extractTokens(e.property):[],a=e.propertyOperator?[e.propertyOperator]:[],l=(r=e.sep)!=null&&r.left?[e.sep.left]:[],p=(o=e.sep)!=null&&o.right?[e.sep.right]:[];return[...n,...s,...l,...a,...p,...i]}if(e instanceof GroupNode){const i=e.prefix?e.prefix instanceof Node?extractTokens(e.prefix):[e.prefix]:[],n=e.paren?[e.paren.left]:[],s=e.paren?[e.paren.right]:[],a=e.expression instanceof Node?extractTokens(e.expression):[e.expression];return[...i,...n,...a,...s]}if(e instanceof ArrayNode){const i=e.values.map(n=>extractTokens(n));return[e.bracket.left,...i.flat(),e.bracket.right]}if(e instanceof ExpressionNode){const i=e.right instanceof Node?extractTokens(e.right):[e.right];return[...e.left instanceof Node?extractTokens(e.left):[e.left],e.operator,...i]}return unreachable()}function getCursorInfo(e,t,r){const o=isArray(t)?t:extractTokens(t);if(e.length<r||r<0)throw new Error(`Index ${r} out of bounds. Input length is ${e.length}.`);const i={index:r,at:void 0,prev:void 0,next:void 0,valid:{prev:void 0,next:void 0},whitespace:{prev:!1,next:!1}};for(const n of o)if(n.end<=r&&(n instanceof ValidToken?(i.prev=n,i.valid.prev=n):n.end!==r&&(i.prev=n)),n.start<r&&n.end>r&&(n instanceof ErrorToken?unreachable():i.at=n),n.start>=r&&(i.next||(i.next=n),n instanceof ValidToken&&!i.valid.next)){i.valid.next=n;break}return setWhitespaceBetween(e,r,"prev",i),setWhitespaceBetween(e,r,"next",i),i}function setWhitespaceBetween(e,t,r,o){const i=r==="next"?"start":"end",n=r==="next"?"end":"start",s=r==="next"?e.length:0;if(o.at)if(o.valid[r]){const a=o.valid[r][i];if(o.at[n]!==a)o.whitespace[r]=!0;else return}else if(o.at[n]!==s)o.whitespace[r]=!0;else return;else if(o.valid[r]){const a=o.valid[r][i];if(t!==a)o.whitespace[r]=!0;else return}else if(t!==s)o.whitespace[r]=!0;else return}function getSurroundingErrors(e,t){if(t.at)return[];const r=e.indexOf(t.next??t.prev);let o=e[r]===t.next?r:r+1,i=e[r]===t.next?r-1:r;const n=[];for(;e[o]instanceof ErrorToken;)n.push(e[o]),o++;for(;e[i]instanceof ErrorToken;)n.push(e[i]),i--;return n.sort((s,a)=>{const l=[TOKEN_TYPE.DOUBLEQUOTE,TOKEN_TYPE.BACKTICK,TOKEN_TYPE.SINGLEQUOTE].includes(s.expected[0]),p=[TOKEN_TYPE.DOUBLEQUOTE,TOKEN_TYPE.BACKTICK,TOKEN_TYPE.SINGLEQUOTE].includes(a.expected[0]),_=[TOKEN_TYPE.PARENR,TOKEN_TYPE.PARENL].includes(s.expected[0]),E=[TOKEN_TYPE.PARENR,TOKEN_TYPE.PARENL].includes(a.expected[0]),d=Math.abs(r-e.indexOf(s)),h=Math.abs(r-e.indexOf(a)),y=d-h;return l===p&&_!==E?_?-1:1:y})}var __defProp=Object.defineProperty,__defNormalProp=(e,t,r)=>t in e?__defProp(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,__publicField=(e,t,r)=>(__defNormalProp(e,typeof t!="symbol"?t+"":t,r),r);const OPPOSITE={[TOKEN_TYPE.AND]:TOKEN_TYPE.OR,[TOKEN_TYPE.OR]:TOKEN_TYPE.AND};function isEqualSet(e,t){if(e.size!==t.size)return!1;for(const r of e)if(!t.has(r))return!1;return!0}const defaultNodeDirs={before:!1,after:!1},createDefaultRequires=(e={})=>({whitespace:{...defaultNodeDirs,...e.whitespace?e.whitespace:{}},group:e.group??!1,prefix:e.prefix??!1}),tokenRequiresWhitespace=(e,t,r)=>t||e===void 0?!1:e.type===TOKEN_TYPE.VALUE||[TOKEN_TYPE.AND,TOKEN_TYPE.OR,TOKEN_TYPE.NOT].includes(e.type)&&r.find(o=>o.value===e.value)!==void 0,tokenVariable=[TOKEN_TYPE.BACKTICK,TOKEN_TYPE.DOUBLEQUOTE,TOKEN_TYPE.SINGLEQUOTE,TOKEN_TYPE.VALUE,TOKEN_TYPE.REGEX];class Parser{constructor(t){__publicField(this,"evaluationOptionsChecked",!1),__publicField(this,"validationOptionsChecked",!1),__publicField(this,"options"),__publicField(this,"lexer"),__publicField(this,"$"),__publicField(this,"$categories"),__publicField(this,"info"),__publicField(this,"state",{rawInput:"",lexedTokens:[],index:0,shift:0}),__publicField(this,"subParserOne"),__publicField(this,"subParserTwo");const r=parseParserOptions(t??{});checkParserOpts(r),this.options=r,this.lexer=new Lexer(r),this.$=this.lexer.$,this.$categories=this.lexer.$categories,this.info={expandedSepAlsoCustom:this.lexer.symbols.expandedSepAlsoCustom,customOpAlsoNegation:this.lexer.symbols.customOpAlsoNegation}}_checkEvaluationOptions(){this.evaluationOptionsChecked||(checkParserOpts(this.options,!0),this.evaluationOptionsChecked=!0)}_checkValidationOptions(){this.validationOptionsChecked||(checkParserOpts(this.options,!1,!0),this.validationOptionsChecked=!0)}lex(t){if(isWhitespace(t))return{tokens:[],shift:0,rawInput:t};let r=this.lexer.tokenize(t);const o=getUnclosedRightParenCount(r),i=t;return o&&(t="(".repeat(o)+t,r=this.lexer.tokenize(t)),{tokens:r.filter(s=>{const a=this.getTokenType(s.type);if(a)return!a.skip;throw new Error(`Unknown token type ${s.type}`)}),shift:o,rawInput:i}}parse(t){var r;const o=((r=arguments[1])==null?void 0:r.seal)??!0;if(typeof t=="string"&&isWhitespace(t))return token.value(void 0,{start:0,end:0});const{tokens:i,shift:n,rawInput:s}=typeof t=="string"?this.lex(t):t;this.state={rawInput:s,shift:n,index:-1,lexedTokens:i};const a=this.ruleMain();return o&&seal(a),this.state={rawInput:"",shift:0,index:-1,lexedTokens:[]},a}createSubParserIfNotExists(t,r="One"){return this[`subParser${r}`]===void 0&&(this[`subParser${r}`]=new Parser(t)),this[`subParser${r}`]}transformCategoryToken(t,r){return{...t,type:r.type}}getCategoryTokens(t){var r;return(r=this.$categories[t])==null?void 0:r.entries}getTokenType(t){return this.$[t]}isExactType(t,r){return this.$[r]?this.isType(t,r):!1}isType(t,r){if(t===void 0)return!1;if(t.type===r)return!0;const o=this.getTokenType(t.type);if((o==null?void 0:o.type)===r)return!0;const i=this.$categories[r];return(i==null?void 0:i.entries[t.type])!==void 0}createErrorToken(t,r){return{type:t,value:"",startOffset:r??this.state.index,endOffset:r??this.state.index,isError:!0}}processToken(t){return t===void 0?[void 0,extractPosition({startOffset:0,endOffset:0},this.state.shift)]:[t.value,extractPosition(t,this.state.shift)]}peek(t=1){return this.state.lexedTokens[this.state.index+t]}nextIsEof(){return this.peek(1)===void 0}consumeAny(){var t;return this.consume((t=this.peek(1))==null?void 0:t.type)}consume(t){if(t===void 0)throw new Error("type is undefined");const r=this.peek(1);if(r===void 0)throw new Error(`Reached end of input without consuming a token of type ${t}`);if(this.$categories[t]!==void 0){const o=this.$categories[t],i=o==null?void 0:o.entries[r.type];if(o&&i)return this.state.index++,this.transformCategoryToken(r,o);throw new Error("here")}else{const o=this.getTokenType(t);if(o!==void 0){if((r==null?void 0:r.type)===o.type)return this.state.index++,r;throw new Error(`Expected token type ${o.type}, got ${r==null?void 0:r.type}`)}}throw new Error(`Unknown token type ${t}`)}saveState(){return{...this.state}}restoreState(t){this.state=t}ruleMain(){const t=this.ruleBool("OR");return t===void 0?token.value(void 0,{start:0,end:0}):t}ruleBool(t){var r;const o=t==="AND"?$C.OPERATOR_AND:$C.OPERATOR_OR,i=[];let n=this.peek(1);for(;i.length<1||((r=i[i.length-1])==null?void 0:r[1])!==void 0;){const a=t==="AND"?this.ruleCondition():this.ruleBool("AND");n=this.peek(1);const l=t==="AND"?["error","and"].includes(this.options.onMissingBooleanOperator):this.options.onMissingBooleanOperator==="or",p=[];if(l&&(this.isType(n,$C.VALUE)||this.isType(n,$C.QUOTE_ANY)||this.isType(n,$T.PAREN_L)||this.isType(n,$T.EXP_PROP_OP)||this.isType(n,$T.REGEX_START)||this.isType(n,$T.CUSTOM_PROP_OP))){let E=this.saveState(),d=this.ruleCondition();if(t==="AND"){let h;for(;d!==void 0;){if(this.options.onMissingBooleanOperator==="and"){const u=this.peek(-1).endOffset+1;h=operator.and("",pos({start:u},{fill:!0}))}p.push([h,d]),E=this.saveState(),d=this.ruleCondition()}this.restoreState(E)}else{const y=this.peek(-1).endOffset+1,u=operator.or("",pos({start:y},{fill:!0}));p.push([u,d])}n=this.peek(1)}const _=this.isType(n,o)&&n?t==="AND"?operator.and(...this.processToken(this.consume(n.type))):operator.or(...this.processToken(this.consume(n.type))):void 0;i.push([a,_]),n=this.peek(1);for(const E of p)i[i.length-1].splice(1,1,E[0]),i.push([E[1]])}if(i.length===0&&this.isType(this.peek(1),o)){n=this.peek(-1);let a=this.saveState();for(;this.isType(n,$C.OPERATOR_AND);){const l=this.consume($C.OPERATOR_AND);for(i.push([void 0,t==="AND"?operator.and(...this.processToken(l)):operator.or(...this.processToken(l))]),n=this.peek(-1);this.isType(n,$C.VALUE)||this.isType(n,$C.QUOTE_ANY)||this.isType(n,$T.PAREN_L);)i.push([this.ruleCondition()]),n=this.peek(-1);a=this.saveState()}this.restoreState(a)}if(t==="AND"&&i.length===0)return;let s=i[i.length-1][0];for(let a=i.length-1;a>0;a--){const l=i[a-1];if(t==="OR"&&s===void 0&&l===void 0)return;s=expression(l[0],l[1],s)}return s}ruleCondition(){var t,r,o,i,n,s,a,l,p,_;const E=this.ruleNot(),d=this.ruleConditionProperty(),h=((t=d==null?void 0:d.prop)==null?void 0:t.value)===void 0?void 0:d.prop.value instanceof ErrorToken?"":d.prop.value.value,y=((r=d==null?void 0:d.rest)==null?void 0:r.propertyOperator)===void 0?void 0:d.rest.propertyOperator instanceof ErrorToken?"":(o=d.rest.propertyOperator)==null?void 0:o.value,u=(((i=d==null?void 0:d.rest)==null?void 0:i.sepL)??((n=d==null?void 0:d.rest)==null?void 0:n.sepR))!==void 0,c=typeof this.options.regexValues=="function"&&!this.options.regexValues(h,y,u),v=typeof this.options.arrayValues=="function"&&!this.options.arrayValues(h,y,u);let O=this.ruleConditionValue(d,{convertRegexValues:c,convertArrayValues:v}),g;if(!(O instanceof ArrayNode)&&!isArray(O)&&(!O||this.options.prefixableGroups)&&this.isType(this.peek(1),$T.PAREN_L)&&(g=this.rulePlainGroup({onlyValues:d!==void 0,convertRegexValues:c,convertArrayValues:v})),isArray(O)&&(g=O,O=void 0),c&&O instanceof VariableNode&&((s=O.quote)==null?void 0:s.left.type)===TOKEN_TYPE.REGEX&&(O=variable(void 0,void 0,token.value((((l=(a=O.quote)==null?void 0:a.left)==null?void 0:l.value)??"")+(O.value.value??"")+(((_=(p=O.quote)==null?void 0:p.right)==null?void 0:_.value)??""),pos(O)),void 0)),g)return d?condition(E,d==null?void 0:d.prop,d==null?void 0:d.rest,group(void 0,void 0,...g)):O?group(void 0,condition(E,void 0,void 0,O),...g):group(E,O,...g);if(![E,d,O].every(R=>R===void 0))return condition(E,d==null?void 0:d.prop,d==null?void 0:d.rest,O)}ruleConditionValue(t,{convertRegexValues:r=!1,convertArrayValues:o=!1}={}){const i=this.peek(1),n=this.peek(2),s=this.peek(3),a=this.peek(4);if(this.options.prefixableGroups&&t===void 0&&(i==null?void 0:i.type)!==$T.PAREN_L&&(this.isType(i,$C.VALUE)&&(this.isType(n,$T.PAREN_L)||this.isType(n,$C.QUOTE_ANY)&&this.isType(s,$T.PAREN_L))||this.isType(i,$C.QUOTE_ANY)&&(this.isType(n,$T.PAREN_L)||this.isType(n,$C.VALUE)&&(this.isType(s,$T.PAREN_L)||this.isType(s,$C.QUOTE_ANY)&&this.isType(a,$T.PAREN_L))))){const l=this.ruleVariable({unprefixed:!0});if(l)return l}if(!this.isType(i,$T.PAREN_L)){const l=this.ruleVariable({unprefixed:!1});if(l)return l}if(this.isType(i,$T.PAREN_L)){const l=this.rulePlainGroup({onlyValues:t!==void 0,convertRegexValues:r,convertArrayValues:o});if(l)return l}if(this.isType(i,$T.BRACKET_L)){const l=this.rulePlainBracketGroup({convertArrayValues:o});if(l)return l}}rulePlainGroup({onlyValues:t=!1,convertRegexValues:r=!1,convertArrayValues:o=!1}={}){const i=this.ruleParenL();let n=0,s,a;const l=t?void 0:this.ruleBool("OR");if(t&&!this.nextIsEof())for(;!this.nextIsEof()&&(!this.isType(this.peek(1),$T.PAREN_R)||n!==0);){const _=this.consumeAny();s??(s=extractPosition(_,this.state.shift).start),_.type===$T.PAREN_L&&n++,_.type===$T.PAREN_R&&n--}s!==void 0&&(a??(a=extractPosition(this.peek(0),this.state.shift).end));const p=this.isType(this.peek(1),$T.PAREN_R)?this.ruleParenR():void 0;if(s!==void 0){const _=this.state.rawInput.slice(s,a);this.createSubParserIfNotExists({...this.options,customPropertyOperators:[],expandedPropertySeparator:void 0,regexValues:r,arrayValues:o},"One");const E=this.subParserOne.parse(" ".repeat(s)+_,{seal:!1});return[i,E,p]}return[i,l,p]}rulePlainBracketGroup({convertArrayValues:t=!1}={}){const r=this.ruleBracketL(),o=[];if(t){if(t&&!this.nextIsEof())for(;!this.nextIsEof()&&!this.isType(this.peek(1),$T.BRACKET_R);)this.consumeAny()}else{let p=this.saveState(),_=this.ruleVariable({unprefixed:!1});for(;_!==void 0;)o.push(_),p=this.saveState(),_=this.ruleVariable({unprefixed:!1});this.restoreState(p)}const i=this.isType(this.peek(1),$T.BRACKET_R)?this.ruleBracketR():void 0;if(r===void 0)throw new Error("bracketL is undefined, peek before using rule.");if(!t)return array(r,o,i);const n=r.start,s=i==null?void 0:i.end,a=this.state.rawInput.slice(n,s);this.createSubParserIfNotExists({...this.options,customPropertyOperators:[],expandedPropertySeparator:void 0,arrayValues:!1},"Two");const l=this.subParserTwo.parse(" ".repeat(n)+a,{seal:!1});return l instanceof ConditionNode?l.value:((l instanceof ErrorToken||l instanceof ExpressionNode||l instanceof GroupNode)&&unreachable("parsed.value should not be an ErrorToken, ExpressionNode, or GroupNode."),l)}ruleConditionProperty(){const t=this.peek(0),r=this.peek(1),o=this.peek(2);if(this.isType(r,$T.EXP_PROP_OP)||this.isType(r,$T.CUSTOM_PROP_OP)||this.isType(r,$T.VALUE_UNQUOTED)&&(this.isType(o,$T.EXP_PROP_OP)||this.isType(o,$T.CUSTOM_PROP_OP))||this.info.customOpAlsoNegation&&(this.isType(o,$T.SYM_NOT)||this.isType(t,$T.SYM_NOT)&&this.isType(r,$T.SYM_NOT)))return this.ruleProperty()}ruleProperty(){const t=this.ruleVariable({unprefixed:!0}),r=this.peek(1);let o={};if(this.isType(r,$T.EXP_PROP_OP)){const i=token.sep(...this.processToken(this.consume($T.EXP_PROP_OP))),n=this.isType(this.peek(1),$T.VALUE_UNQUOTED)?token.value(...this.processToken(this.consume($T.VALUE_UNQUOTED))):void 0,s=this.isType(this.peek(1),$T.EXP_PROP_OP)?token.sep(...this.processToken(this.consume($T.EXP_PROP_OP))):void 0;this.info.expandedSepAlsoCustom&&n===void 0&&s===void 0?(setReadOnly(i,"type",TOKEN_TYPE.OP_CUSTOM),o={sepL:void 0,sepR:s,propertyOperator:i}):o={sepL:i,sepR:s,propertyOperator:n}}else this.isType(r,$T.CUSTOM_PROP_OP)?o={propertyOperator:token.custom(...this.processToken(this.consume($T.CUSTOM_PROP_OP)))}:this.info.customOpAlsoNegation&&this.isType(r,$T.SYM_NOT)&&(o={propertyOperator:token.custom(...this.processToken(this.consume($T.SYM_NOT)))});return{prop:t,rest:o}}ruleVariable({unprefixed:t=!1}={}){const r=this.ruleVariablePrefix({onlyToken:!0,unprefixed:t}),o=this.peek(1),i=this.peek(2),n=this.peek(3);if(o&&(this.isExactType(o,$T.QUOTE_DOUBLE)||this.isExactType(o,$T.QUOTE_SINGLE)||this.isExactType(o,$T.QUOTE_BACKTICK))){const s=o.type;if((i==null?void 0:i.type)===s){const a=this.ruleQuote(s),l=this.ruleQuote(s);return variable(void 0,a,void 0,l)}if((n==null?void 0:n.type)===o.type){const a=this.ruleQuote(s),l=this.isType(i,$T.VALUE_UNQUOTED)?this.ruleValueUnquoted({}):this.ruleValueNot(s),p=this.ruleQuote(s),_=r?token.value(...this.processToken(r)):void 0;return variable(_,a,l,p)}}if(this.isType(o,$C.REGEX_ANY)){const s=this.ruleRegexAny(),a=this.peek(1),l=this.isType(a,$T.VALUE_REGEX)?this.ruleValueNot($C.REGEX_ANY):void 0,p=this.isType(this.peek(1),$C.REGEX_ANY)?this.ruleRegexAny():void 0,_=isArray(p)?p:[p,void 0];return variable(void 0,s,l,_[0],_[1])}if(this.isType(o,$T.VALUE_UNQUOTED)&&this.isType(i,$C.QUOTE_ANY)){const s=this.ruleValueUnquoted(),a=this.ruleValueDelimAny();return variable(void 0,void 0,s,a)}if(this.isType(o,$C.QUOTE_ANY)){const s=o,a=this.ruleValueDelimAny(),l=this.peek(1),p=!a&&this.isType(l,$T.VALUE_UNQUOTED)?this.ruleValueUnquoted():a&&this.isType(l,s.type.replace("QUOTE","VALUE_FOR"))?this.ruleValueNot(s.type):void 0;return variable(void 0,a,p,void 0)}if(this.isType(o,$T.VALUE_UNQUOTED)){const s=this.ruleValueUnquoted();return variable(void 0,void 0,s,void 0)}}ruleValueDelimAny(){const t=this.peek(1);if(this.isType(t,$C.QUOTE_ANY)){const r=t.value==='"'?"double":t.value==="'"?"single":t.value==="`"?"tick":"regex";return delimiter[r](...this.processToken(this.consume($C.QUOTE_ANY)))}}ruleRegexAny(){const t=this.consume($C.REGEX_ANY);if(t.value.length>1){const r={value:"/",startOffset:t.startOffset,endOffset:t.startOffset},o={value:t.value.slice(1),startOffset:t.startOffset+1,endOffset:t.endOffset};return[delimiter.regex(...this.processToken(r)),token.value(...this.processToken(o))]}return delimiter.regex(...this.processToken(t))}ruleValueNot(t){const r={[$T.QUOTE_SINGLE]:$C.VALUE_FOR_SINGLE,[$T.QUOTE_DOUBLE]:$C.VALUE_FOR_DOUBLE,[$T.QUOTE_BACKTICK]:$C.VALUE_FOR_BACKTICK,[$C.REGEX_ANY]:$T.VALUE_REGEX}[t];r===void 0&&unreachable(`Unknown quote/regex type ${t}`);const o=this.consume(r);return r!==o.type&&unreachable(`Expected value type ${r}, got ${o.type}`),token.value(...this.processToken(o))}ruleQuote(t){const r=this.peek(1);if(t!==(r==null?void 0:r.type))throw new Error(`Expected quote type ${t}, got ${r==null?void 0:r.type}`);switch(t){case $T.QUOTE_SINGLE:return delimiter.single(...this.processToken(this.consume($T.QUOTE_SINGLE)));case $T.QUOTE_DOUBLE:return delimiter.double(...this.processToken(this.consume($T.QUOTE_DOUBLE)));case $T.QUOTE_BACKTICK:return delimiter.tick(...this.processToken(this.consume($T.QUOTE_BACKTICK)))}throw new Error(`Expected quote type ${t}`)}ruleVariablePrefix({onlyToken:t=!1,unprefixed:r=!1}={}){const o=this.peek(1),i=this.peek(2),n=this.peek(4);if(!r&&this.options.prefixableStrings!==void 0&&this.isType(i,$C.QUOTE_ANY)&&i&&this.isType(n,i.type)&&o&&this.options.prefixableStrings.includes(o.value))return this.ruleValueUnquoted({onlyToken:t});if(!t)return token.value(...this.processToken())}ruleValueUnquoted({onlyToken:t=!1}={}){const r=this.consume($T.VALUE_UNQUOTED);return t?r:token.value(...this.processToken(r))}ruleParenL(){const t=this.peek(1),r=(t==null?void 0:t.type)===$T.PAREN_L?this.consume($T.PAREN_L):this.createErrorToken($T.PAREN_L),o=extractPosition(r,this.state.shift);return this.state.shift===0||o.start>0?delimiter.parenL(r.isError?void 0:r.value,o):void 0}ruleParenR(){const t=this.consume($T.PAREN_R);return delimiter.parenR(...this.processToken(t))}ruleBracketL(){const t=this.peek(1),r=(t==null?void 0:t.type)===$T.BRACKET_L?this.consume($T.BRACKET_L):this.createErrorToken($T.BRACKET_L),o=extractPosition(r,this.state.shift);return this.state.shift===0||o.start>0?delimiter.bracketL(r.isError?void 0:r.value,o):void 0}ruleBracketR(){const t=this.consume($T.BRACKET_R);return delimiter.bracketR(...this.processToken(t))}ruleNot(){if(this.isType(this.peek(1),$C.OPERATOR_NOT)){const t=this.consume($C.OPERATOR_NOT);return operator.not(...this.processToken(t))}}autocomplete(t,{values:r=[],arrayValues:o=[],variables:i=[],prefixes:n=[],properties:s=[],expandedPropertyOperators:a=[],customPropertyOperators:l=this.options.customPropertyOperators??[],keywords:p=this.options.keywords,regexFlags:_=["i","m","u"],quote:E='"'}={}){const d=this;return t.map(h=>{const y=h.type;switch(y){case SUGGESTION_TYPE.BACKTICK:return[{suggestion:h,value:"`"}];case SUGGESTION_TYPE.DOUBLEQUOTE:return[{suggestion:h,value:'"'}];case SUGGESTION_TYPE.SINGLEQUOTE:return[{suggestion:h,value:"'"}];case SUGGESTION_TYPE.PARENL:return[{suggestion:h,value:"("}];case SUGGESTION_TYPE.PARENR:return[{suggestion:h,value:")"}];case SUGGESTION_TYPE.BRAKCETR:return[{suggestion:h,value:"]"}];case SUGGESTION_TYPE.REGEX:return[{suggestion:h,value:"/"}];case SUGGESTION_TYPE.REGEX_FLAGS:return _.map(u=>({suggestion:h,value:u})).filter(u=>{var c,v,O,g,R,N,P;const{suggestion:A,value:m}=u;if(A.type!==SUGGESTION_TYPE.REGEX_FLAGS)return!0;const T=A.cursorInfo,S=T.at&&((v=(c=T.at.parent)==null?void 0:c.quote)==null?void 0:v.flags)===A.cursorInfo.at?T.at:T.next&&((g=(O=T.next.parent)==null?void 0:O.quote)==null?void 0:g.flags)===A.cursorInfo.next?T.next:T.prev&&((N=(R=T.prev.parent)==null?void 0:R.quote)==null?void 0:N.flags)===A.cursorInfo.prev?T.prev:void 0;return!((P=S==null?void 0:S.value)!=null&&P.includes(m))});case SUGGESTION_TYPE.PROPERTY:return s.map(u=>({suggestion:h,value:u}));case SUGGESTION_TYPE.PROPERTY_SEP:return[{suggestion:h,value:d.options.expandedPropertySeparator}];case SUGGESTION_TYPE.EXPANDED_PROPERTY_OPERATOR:return a.map(u=>({suggestion:h,value:u}));case SUGGESTION_TYPE.CUSTOM_PROPERTY_OPERATOR:return l.map(u=>({suggestion:h,value:u}));case SUGGESTION_TYPE.BOOLEAN_SYMBOL_OP:return[...p.and,...p.or].filter(v=>v.isSymbol).map(({value:v})=>({suggestion:h,value:v}));case SUGGESTION_TYPE.BOOLEAN_WORD_OP:return[...p.and,...p.or].filter(v=>!v.isSymbol).map(({value:v})=>({suggestion:h,value:v}));case SUGGESTION_TYPE.VALUE:case SUGGESTION_TYPE.ARRAY_VALUE:case SUGGESTION_TYPE.VARIABLE:return(y===SUGGESTION_TYPE.VARIABLE?i:y===SUGGESTION_TYPE.ARRAY_VALUE?o:y===SUGGESTION_TYPE.VALUE?r:unreachable()).map(c=>{const v=d.parse(c);return v instanceof ConditionNode&&v.operator===void 0&&v.value instanceof VariableNode&&v.value.quote===void 0?{suggestion:h,value:v.value.value.value}:{suggestion:h,value:E+c.replace(new RegExp(E,"g"),`\\${E}`)+E}});case SUGGESTION_TYPE.PREFIX:return n.map(u=>{const c=d.parse(u);return c instanceof ConditionNode&&c.operator===void 0&&c.value instanceof VariableNode&&c.value.quote===void 0?{suggestion:h,value:c.value.value.value}:{suggestion:h,value:E+u.replace(new RegExp(E,"g"),`\\${E}`)+E}})}}).flat()}autoreplace(t,{value:r,suggestion:o}){const i=['"',"'","`"].includes(r[0]),n=['"',"'","`"].includes(r[r.length-1]);if(i&&!n||!i&&n)throw new Error(`Completion value must either be entirely quoted or entirely unquoted. But the left side is ${i?"quoted":"unquoted"} and the right side is ${n?"quoted":"unquoted"}.`);let s=o.range.start+r.length;return o.requires.prefix&&(r=o.requires.prefix+(i?"":'"')+r+(n?"":'"'),s+=o.requires.prefix.length+ +!i+ +!n),o.requires.group&&(r+="()",s++),o.requires.whitespace.before&&(r=` ${r}`,s++),o.requires.whitespace.after&&(r=`${r} `),{replacement:insert(r,t,[o.range.start,o.range.end]),cursor:s}}autosuggest(t,r,o){var i,n,s,a,l,p,_,E,d,h,y,u,c,v,O,g,R,N,P,A,m,T,S,b,k,K,B,G,D,Q,H,q,J,ce,de,fe,_e,Ee;const X=this.options,he=extractTokens(r),f=getCursorInfo(t,he,o),Z=[...X.keywords.and,...X.keywords.or,...X.keywords.not].filter(ne=>!ne.isSymbol),oe=f.valid.prev&&tokenVariable.includes((i=f.valid.prev)==null?void 0:i.type)&&(f.whitespace.prev||f.valid.prev.type===TOKEN_TYPE.PARENR)&&!f.at&&f.valid.next===void 0,ve=f.valid.next&&tokenVariable.includes((n=f.valid.next)==null?void 0:n.type)&&f.whitespace.next&&!f.at&&f.valid.prev===void 0,j=tokenRequiresWhitespace(f.valid.prev,f.whitespace.prev,Z),ie=tokenRequiresWhitespace(f.valid.next,f.whitespace.next,Z),Te=oe?!1:j,Oe=!oe&&ve?!1:ie,x=[];if(r instanceof ErrorToken)x.push({type:SUGGESTION_TYPE.PREFIX,requires:createDefaultRequires({group:!0}),range:pos({start:o},{fill:!0}),isError:!0,cursorInfo:f}),x.push({type:SUGGESTION_TYPE.VARIABLE,requires:createDefaultRequires(),range:pos({start:o},{fill:!0}),isError:!0,cursorInfo:f});else{const ne=getSurroundingErrors(he,f),ee=[],V={isError:!0,cursorInfo:f},I={isError:!1,cursorInfo:f};for(const $ of ne)for(const L of $.expected)if(!ee.includes(L))switch(ee.push(L),L){case TOKEN_TYPE.DOUBLEQUOTE:case TOKEN_TYPE.SINGLEQUOTE:case TOKEN_TYPE.BACKTICK:{const w=$.parent.quote.left===$,z=$.parent.quote.right===$;x.push({...V,type:L,requires:createDefaultRequires({whitespace:{before:z?!1:j,after:w?!1:ie}}),range:pos({start:o},{fill:!0})})}break;case TOKEN_TYPE.AND:case TOKEN_TYPE.OR:x.push({...V,type:SUGGESTION_TYPE.BOOLEAN_SYMBOL_OP,requires:createDefaultRequires(),range:pos({start:o},{fill:!0})}),x.push({...V,type:SUGGESTION_TYPE.BOOLEAN_WORD_OP,requires:createDefaultRequires({whitespace:{before:Te,after:Oe}}),range:pos({start:o},{fill:!0})}),L===TOKEN_TYPE.AND&&ee.push(TOKEN_TYPE.OR),L===TOKEN_TYPE.OR&&ee.push(TOKEN_TYPE.AND);break;case TOKEN_TYPE.PARENL:case TOKEN_TYPE.PARENR:x.push({...V,type:L,requires:createDefaultRequires(),range:pos({start:o},{fill:!0})});break;case TOKEN_TYPE.VALUE:{const w=$.parent instanceof VariableNode?(a=(s=$.parent)==null?void 0:s.prefix)==null?void 0:a.value:!1;$.parent instanceof VariableNode&&(((l=$.parent.quote)==null?void 0:l.left.type)===TOKEN_TYPE.REGEX||((p=$.parent.quote)==null?void 0:p.right.type)===TOKEN_TYPE.REGEX)||(!w&&X.prefixableGroups&&x.push({...V,type:SUGGESTION_TYPE.PREFIX,requires:createDefaultRequires({whitespace:{before:j,after:!1},group:!0}),range:pos({start:o},{fill:!0})}),x.push({...V,type:SUGGESTION_TYPE.VARIABLE,requires:createDefaultRequires({whitespace:{before:j,after:ie},prefix:w}),range:pos({start:o},{fill:!0})}));break}case TOKEN_TYPE.BRACKETR:{x.push({...V,type:SUGGESTION_TYPE.BRAKCETR,requires:createDefaultRequires(),range:pos({start:o},{fill:!0})});break}case TOKEN_TYPE.OP_EXPANDED_SEP:x.push({...V,type:SUGGESTION_TYPE.PROPERTY_SEP,requires:createDefaultRequires(),range:pos({start:o},{fill:!0})});break;case TOKEN_TYPE.REGEX:x.push({...V,type:SUGGESTION_TYPE.REGEX,requires:createDefaultRequires(),range:pos({start:o},{fill:!0})});break;case TOKEN_TYPE.OP_CUSTOM:case TOKEN_TYPE.BRACKETL:case TOKEN_TYPE.NOT:unreachable()}const C=(_=f.valid.prev)==null?void 0:_.parent,U=(E=f.valid.next)==null?void 0:E.parent,F=C==null?void 0:C.parent,M=U==null?void 0:U.parent,Y=(d=f.at)==null?void 0:d.parent,te=Y==null?void 0:Y.parent,se=!f.whitespace.prev&&((h=f.valid.prev)==null?void 0:h.type)!==TOKEN_TYPE.REGEX&&C instanceof VariableNode&&(F instanceof ConditionNode&&F.value===C&&(((y=C.quote)==null?void 0:y.right)===f.valid.prev||C.value===f.valid.prev)||F instanceof ArrayNode),Se=!f.whitespace.next&&((u=f.valid.next)==null?void 0:u.type)!==TOKEN_TYPE.REGEX&&U instanceof VariableNode&&(M instanceof ConditionNode&&M.value===U&&(((c=U.quote)==null?void 0:c.left)===f.valid.next||U.value===f.valid.next)||M instanceof ArrayNode),xe=Y instanceof VariableNode&&te instanceof ConditionNode||C instanceof VariableNode&&f.valid.prev===((v=C==null?void 0:C.quote)==null?void 0:v.left)||U instanceof VariableNode&&f.valid.next===((O=U==null?void 0:U.quote)==null?void 0:O.right),ae=F instanceof ConditionNode&&C!==void 0&&C===(F==null?void 0:F.property),be=M instanceof ConditionNode&&U!==void 0&&U===(M==null?void 0:M.property),Ce=te instanceof ConditionNode&&Y!==void 0&&Y===(te==null?void 0:te.property),le=C instanceof ConditionNode&&f.valid.prev===(C==null?void 0:C.propertyOperator),Ue=U instanceof ConditionNode&&f.valid.next===(U==null?void 0:U.propertyOperator),Le=Y instanceof ConditionNode&&f.at===(Y==null?void 0:Y.propertyOperator),re=((g=f.valid.prev)==null?void 0:g.type)===TOKEN_TYPE.BRACKETL&&(f.valid.next===void 0||((R=f.valid.next)==null?void 0:R.type)===TOKEN_TYPE.BRACKETR),W=se?f.valid.prev:!re&&!ae&&!le&&Se?f.valid.next:xe?f.at:void 0,Ne=ae?f.valid.prev:!re&&!se&&!le&&be?f.valid.next:Ce?f.at:void 0,pe=le?f.valid.prev:!re&&!se&&!ae&&Ue?f.valid.next:Le?f.at:void 0;if(W){const $=W.parent;if($ instanceof VariableNode){const L=pos($),w=$==null?void 0:$.parent,z=w.propertyOperator!==void 0&&w.value===$,ye=(N=$==null?void 0:$.parent)==null?void 0:N.parent,ue=ye instanceof GroupNode&&ye.prefix===w,Re=getCursorInfo(t,r,$.start),Pe=getCursorInfo(t,r,$.end),Ae=tokenRequiresWhitespace(Re.valid.prev,Re.whitespace.prev,Z),ke=tokenRequiresWhitespace(Pe.valid.next,Pe.whitespace.next,Z),ge=W.parent instanceof VariableNode?(A=(P=W.parent)==null?void 0:P.prefix)==null?void 0:A.value:!1,Ie=((m=f.prev)==null?void 0:m.type)===TOKEN_TYPE.OP_EXPANDED_SEP,me=((T=W.parent)==null?void 0:T.parent)instanceof ArrayNode,$e=W===((S=$.quote)==null?void 0:S.flags);!$e&&!Ie&&!z&&!me&&!ge&&X.prefixableGroups&&x.push({...I,type:SUGGESTION_TYPE.PREFIX,requires:createDefaultRequires({group:!ue,whitespace:{before:Ae&&!ue,after:!1}}),range:L}),!$e&&!ue&&x.push({...I,type:me?SUGGESTION_TYPE.ARRAY_VALUE:z?SUGGESTION_TYPE.VALUE:SUGGESTION_TYPE.VARIABLE,requires:createDefaultRequires({whitespace:{before:Ae,after:ke},prefix:ge}),range:L})}}if(re&&x.push({...I,type:SUGGESTION_TYPE.ARRAY_VALUE,requires:createDefaultRequires(),range:pos({start:o},{fill:!0})}),Ne&&x.push({...I,type:SUGGESTION_TYPE.PROPERTY,requires:createDefaultRequires(),range:pos(Ne)}),pe&&x.push({...I,type:pe.parent.sep?SUGGESTION_TYPE.EXPANDED_PROPERTY_OPERATOR:SUGGESTION_TYPE.CUSTOM_PROPERTY_OPERATOR,requires:createDefaultRequires(),range:pos(pe)}),f.whitespace.next&&(f.whitespace.prev||((b=f.prev)==null?void 0:b.type)===TOKEN_TYPE.BRACKETL||((k=f.prev)==null?void 0:k.type)===TOKEN_TYPE.PARENL)||f.whitespace.prev&&(f.whitespace.next||((K=f.next)==null?void 0:K.type)===TOKEN_TYPE.BRACKETR||((B=f.next)==null?void 0:B.type)===TOKEN_TYPE.PARENR)){const $=[M,F,U,C].find(w=>w instanceof ArrayNode)!==void 0,L=["and","or"].includes(X.onMissingBooleanOperator);($||L)&&x.push({type:$?SUGGESTION_TYPE.ARRAY_VALUE:SUGGESTION_TYPE.VARIABLE,requires:createDefaultRequires({}),range:pos({start:o},{fill:!0}),...I}),!$&&L&&x.push({...I,type:SUGGESTION_TYPE.PREFIX,requires:createDefaultRequires({group:!0}),range:pos({start:o},{fill:!0})})}if((f.at&&f.at===((Q=(D=(G=f.at)==null?void 0:G.parent)==null?void 0:D.quote)==null?void 0:Q.flags)||f.valid.prev&&f.valid.prev===((J=(q=(H=f.valid.prev)==null?void 0:H.parent)==null?void 0:q.quote)==null?void 0:J.flags)||f.valid.next&&f.valid.next===((fe=(de=(ce=f.valid.next)==null?void 0:ce.parent)==null?void 0:de.quote)==null?void 0:fe.flags)||((_e=f.valid.prev)==null?void 0:_e.type)===TOKEN_TYPE.REGEX&&f.valid.prev===((Ee=f.valid.prev.parent.quote)==null?void 0:Ee.right))&&x.push({...I,type:SUGGESTION_TYPE.REGEX_FLAGS,requires:createDefaultRequires(),range:pos({start:o},{fill:!0})}),oe||ve){const $=pos({start:o},{fill:!0});x.push({...I,type:SUGGESTION_TYPE.BOOLEAN_SYMBOL_OP,requires:createDefaultRequires(),range:$}),x.push({...I,type:SUGGESTION_TYPE.BOOLEAN_WORD_OP,requires:createDefaultRequires({whitespace:{before:Te,after:Oe}}),range:$})}}return x}evaluate(t,r){this._checkEvaluationOptions();const o=this.options;if(t instanceof Condition){const i=get(r,t.property),n=o.valueComparer({property:t.property,value:t.value,operator:t.operator},i,r);return t.negate?!n:n}if(t instanceof Expression){const i=this.evaluate(t.left,r),n=this.evaluate(t.right,r);return t.operator===TOKEN_TYPE.AND?i&&n:i||n}return unreachable()}getBestIndexes(t,r,o=""){t=t.filter(s=>{for(const a of s)if(!r.has(a))return!1;return!0});let i=t;if(r.has(o)){const s=t.filter(a=>a.has(o));s.length>0&&(i=s)}let n=1/0;if(r instanceof Map){const s=new Map;for(const a of i){let l=0;for(const p of a)l+=r.get(p)??0;s.set(a,l),n=l<n?l:n}return t.filter(a=>n===1/0||s.get(a)===n)}else{for(const s of i)n=s.size<n?s.size:n;return t.filter(s=>n===1/0||s.size===n)}}getIndexes(t){if(t instanceof Condition)return[new Set(t.property.join("."))];if(t instanceof Expression){const r=this.getIndexes(t.left),o=this.getIndexes(t.right);if(t.operator===TOKEN_TYPE.AND){const i=[],n=new Set;for(const a of r)if(!i.find(p=>isEqualSet(p,a))){i.push(a);for(const p of a)n.add(p)}for(const a of o)if(!i.find(p=>isEqualSet(p,a))){i.push(a);for(const p of a)n.add(p)}const s=new Set;e:for(const a of n){for(const l of i)if(!l.has(a))continue e;s.add(a)}return s.size>0?[s,n]:i}if(t.operator===TOKEN_TYPE.OR){for(const n of o)for(const s of r)if(isEqualSet(s,n))return[n];const i=new Set;for(const n of r)for(const s of n)i.add(s);for(const n of o)for(const s of n)i.add(s);return[i]}}return unreachable()}normalize(t){var r,o,i,n,s,a,l,p,_,E,d,h,y;this._checkEvaluationOptions();const u=this.options;if(t instanceof ErrorToken||!t.valid)throw new Error("AST node must be valid.");const c=arguments[1],v=arguments[2];let O=arguments[3];const g=this;if(t instanceof ConditionNode)if(t.value instanceof GroupNode){let R=unescape(t.property.value.value);c!==void 0&&(R=applyPrefix(c,R,u.prefixApplier));const N=applyBoolean(v,t.operator===void 0),P=(y=t.propertyOperator)==null?void 0:y.value;return g.normalize(t.value,R,N,P)}else{const R=t.value instanceof ArrayNode||((o=(r=t.value)==null?void 0:r.quote)==null?void 0:o.left.type)===TOKEN_TYPE.REGEX;let N=t.property?unescape(t.property.value.value):R?void 0:unescape((i=t.value)==null?void 0:i.value.value);const P=O!==void 0;c!==void 0&&!P&&(N=N?applyPrefix(c,N,u.prefixApplier):c);let A;P?(A=N??!0,N=c):A=t.value instanceof ArrayNode?t.value.values.map(Q=>unescape(Q.value.value)):((s=(n=t.value)==null?void 0:n.quote)==null?void 0:s.left.type)===TOKEN_TYPE.REGEX?t.value.value.value:t.property&&t.value instanceof VariableNode?unescape(t.value.value.value):!0;const m=N?u.keyParser(N):[],T=applyBoolean(v,t.operator===void 0),S=t.value instanceof VariableNode&&t.value.prefix?unescape(t.value.prefix.value):void 0;O??(O=(a=t.propertyOperator)==null?void 0:a.value);const b=((p=(l=t.value)==null?void 0:l.quote)==null?void 0:p.left.type)===TOKEN_TYPE.REGEX,k=((_=t.value)==null?void 0:_.quote)!==void 0,K=t.sep!==void 0,B=(h=(d=(E=t.value)==null?void 0:E.quote)==null?void 0:d.flags)==null?void 0:h.value,G={value:A,operator:O,prefix:S,regexFlags:B,property:m,isRegex:b,isQuoted:k,isExpanded:K,isNegated:!T,condition:t},D=u.conditionNormalizer(G);return new Condition({property:m,...D})}if(t instanceof GroupNode){const R=t.prefix instanceof ConditionNode&&t.prefix.value instanceof VariableNode?unescape(t.prefix.value.value.value):void 0,N=t.prefix instanceof ConditionNode?t.prefix.operator===void 0:!(t.prefix instanceof ValidToken),P=applyPrefix(c,R??"",u.prefixApplier);return g.normalize(t.expression,P,applyBoolean(v,N),O)}if(t instanceof ExpressionNode){const R=g.normalize(t.left,c,v,O),N=g.normalize(t.right,c,v,O),P=v===!1?OPPOSITE[t.operator.type]:t.operator.type;return new Expression({operator:P,left:R,right:N})}return unreachable()}validate(t,r){var o,i,n,s,a,l,p,_,E;const d=this;d._checkValidationOptions();const h=d.options;if(t instanceof ErrorToken||!t.valid)throw new Error("AST node must be valid.");const y=arguments[2],u=arguments[3],c=arguments[4]??[],v=arguments[5]??[];let O=arguments[6];const g=this;if(t instanceof ConditionNode)if(t.value instanceof GroupNode){let R=unescape(t.property.value.value);y!==void 0&&(R=applyPrefix(y,R,h.prefixApplier));const N=applyBoolean(u,t.operator===void 0);t.property&&v.push(t.property);const P=t.propertyOperator;g.validate(t.value,r,R,N,c,v,P)}else{const R=t.value instanceof ArrayNode||((i=(o=t.value)==null?void 0:o.quote)==null?void 0:i.left.type)===TOKEN_TYPE.REGEX,N=t.property?t.property:R?void 0:t.value;let P=N?unescape(N.value.value):void 0;const A=O!==void 0;y!==void 0&&!A&&(P=P?applyPrefix(y,P,h.prefixApplier):y);let m,T=[];A?(m=P,P=y,T=[...v]):(T=[...v,...N?[N]:[]],m=t.value instanceof ArrayNode?t.value.values:((s=(n=t.value)==null?void 0:n.quote)==null?void 0:s.left.type)===TOKEN_TYPE.REGEX||t.property&&t.value instanceof VariableNode?t.value:!0);const S=P?h.keyParser(P):[],b=r!==void 0?get(r,S):void 0,k=applyBoolean(u,t.operator===void 0),K=t.value instanceof VariableNode&&t.value.prefix?t.value.prefix:void 0;O??(O=t.propertyOperator);const B=((l=(a=t.value)==null?void 0:a.quote)==null?void 0:l.left.type)===TOKEN_TYPE.REGEX,G=((p=t.value)==null?void 0:p.quote)!==void 0,D=t.sep!==void 0,Q=(E=(_=t.value)==null?void 0:_.quote)==null?void 0:E.flags,H={value:m,operator:O,prefix:K,prefixes:v,property:T,propertyKeys:S,propertyName:P,regexFlags:Q,isRegex:B,isNegated:!k,isQuoted:G,isExpanded:D,condition:t},q=h.valueValidator(b,H,r);if(q&&!isArray(q))throw new Error("The valueValidator must return an array or nothing/undefined");if(q)for(const J of q)c.push(J)}if(t instanceof GroupNode){const R=t.prefix instanceof ConditionNode&&t.prefix.value instanceof VariableNode?t.prefix.value:void 0;R&&v.push(R);const N=t.prefix instanceof ConditionNode?t.prefix.operator===void 0:!(t.prefix instanceof ValidToken);g.validate(t.expression,r,applyPrefix(y,(R==null?void 0:R.value.value)??"",h.prefixApplier),applyBoolean(u,N),c,v,O)}return t instanceof ExpressionNode&&(g.validate(t.left,r,y,u,c,[...v],O),g.validate(t.right,r,y,u,c,[...v],O)),c}}const red="\x1B[31m",green="\x1B[32m",yellow="\x1B[33m",blue="\x1B[34m",cyan="\x1B[36m",reset="\x1B[0m",defaultColors={values:yellow,info:cyan,position:green,hint:blue,error:red,reset},disableColors=Object.fromEntries(Object.keys(defaultColors).map(e=>[e,""])),toRows=(e,t)=>(e=e.filter(r=>r!==""),[...e.slice(0,e.length-1).map(r=>`${t.indent}${t.children}${r}`),`${t.indent}${t.last}${e[e.length-1]}`]);function prettyAst(e,{indent:t="   ",children:r="├╴",last:o="└╴",branch:i="│",quote:n=""}={},s={}){var a,l,p,_,E,d,h,y;const u={indent:t,children:r,last:o,branch:i,quote:n},c=s?{...defaultColors,...s}:disableColors,v=`${c.position}(${e.start}, ${e.end})${c.reset}`,O=t,g=arguments[3]??"";let R=arguments[4]??"";isBlank(R)||(R=` ${c.hint}${R}${c.reset}`);const N=g+O+i,P=g+O+t[0],A=prettyAst;if(e instanceof ValidToken){const m=`${e.value}`;return`TOKEN ${v} ${c.values}${n}${m}${n}${c.reset}${R}`}if(e instanceof ErrorToken){const m=`[${e.expected.join(", ")}]`;return`ERROR ${v} ${c.error}${m}${c.reset}${R}`}if(e instanceof ConditionNode){const m=`${c.info}${e.operator===void 0}${c.reset}`,T=e.operator?A(e.operator,u,c,N,"(negation)"):"",S=e.property?A(e.property,u,c,N,"(property)"):"",b=(a=e.sep)!=null&&a.left?A(e.sep.left,u,c,N,"(separator)"):"",k=e.propertyOperator?A(e.propertyOperator,u,c,N,"(property operator)"):"",K=(l=e.sep)!=null&&l.right?A(e.sep.right,u,c,N,"(separator)"):"",B=e.value instanceof VariableNode&&((p=e.value.quote)==null?void 0:p.left.type)===TOKEN_TYPE.REGEX,G=e.value instanceof ArrayNode,D=A(e.value,u,c,P,`(${S?"value":"variable/alone"}${B?" - regex":G?"- array":""})`);return[`CONDITION ${v} ${m}${R}`,...toRows([T,S,b,k,K,D],u)].join(`
${g}`)}if(e instanceof VariableNode){const m=e.prefix?A(e.prefix,u,c,N,"(value prefix)"):"",T=(_=e.quote)!=null&&_.left?A(e.quote.left,u,c,N,""):"",S=A(e.value,u,c,e.quote&&(E=e.quote)!=null&&E.right?N:P,""),b=(d=e.quote)!=null&&d.right?A(e.quote.right,u,c,(h=e.quote)!=null&&h.flags?N:P,""):"",k=(y=e.quote)!=null&&y.flags?A(e.quote.flags,u,c,P,"(flags)"):"";return[`VARIABLE ${v}${R}`,...toRows([m,T,S,b,k],u)].join(`
${g}`)}if(e instanceof GroupNode){const m=`${c.info}${e.prefix===void 0||e.prefix.operator===void 0}${c.reset}`,T=e.prefix?A(e.prefix,u,c,N,"(group prefix)"):"",S=A(e.expression,u,c,P,"");return[`GROUP ${v}${R.includes("value")?"":` ${m}`}${R}`,...toRows([T,S],u)].join(`
${g}`)}if(e instanceof ArrayNode){const m=e.bracket.left?A(e.bracket.left,u,c,e.values.length===0&&!e.bracket.right?P:N,""):"",T=e.values.length>0?e.values.map((b,k)=>A(b,u,c,!e.bracket.right&&k===e.values.length-1?P:N,"")):[],S=e.bracket.right?A(e.bracket.right,u,c,P,""):"";return[`ARRAY ${v} ${c.info}[${e.values.length}]${c.reset}${R}`,...toRows([m,...T,S],u)].join(`
${g}`)}if(e instanceof ExpressionNode){const m=A(e.left,u,c,N,""),T=A(e.operator,u,c,N,"(boolean operator)"),S=A(e.right,u,c,P,""),b=e.operator instanceof ErrorToken?`${c.info}[${e.operator.expected.join(",")}]${c.reset}`:`${c.info}"${e.operator.value}"${c.reset}`;return[`EXPRESSION ${v} ${b}${R}`,...toRows([m,T,S],u)].join(`
${g}`)}unreachable()}const body=document.body;body.innerHTML=`
<div class="container">
	<input class="input" spellcheck="false"/>
	<div class="options">
		<h2>Options</h2>
		<div class="options-group">
			<textarea spellcheck="false" class="options-raw">${crop(`
			{
				customPropertyOperators: [":", ">", "<"],
				expandedPropertySeparator: ":",
				prefixableStrings: ["num"]
			}`)}</textarea>
			<textarea class="options-parsed" disabled="true"></textarea>
		</div>
	</div>
	<div>
		<div class="suggestions">
		<div class="suggestions-heading"><h2>Suggestions</h2><span>(press Ctrl+Space to force suggestions at cursor)</span><span class="pos"></span></div>
			<div class="suggestion">
			</div>
		</div>
		<div class="completions">
		<div class="completions-heading"><h2>Completions</h2></div>
			<div class="completion">
			</div>
		</div>
	</div>
	<div>
		<div class="results-heading"><h2>Results</h2> <span class="time">(<span class="resultTime"></span>ms)</span></div>
		<div class="results">
			<div class="result resultSimple"></div>
			<div class="result resultFull"></div>
		</div>
	</div>
</div>
`;function escapeHtml(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;")}const els={};let opts,parser,ast,first=!0;function onInput(e){const t=els.input.value;let r;try{r=getOpts()}catch{return}let o,i;(!parser||JSON.stringify(opts)!==JSON.stringify(r))&&(o=performance.now(),opts=r,parser=new Parser({...opts,cache:!0}),i=performance.now()-o),first&&(i=void 0,first=!1);let n,s;setTimeout(()=>{try{s=performance.now(),ast=parser.parse(t),n=performance.now()-s}catch(l){n=performance.now()-s,els.resultTime.innerHTML=n.toFixed(2)+(i?` + ${i.toFixed(2)} (parser re-instantiated)`:""),els.resultFull.innerHTML=l.message,els.resultSimple.innerHTML="UNEXPECTED ERROR - Please file an issue =>";return}els.resultTime.innerHTML=n.toFixed(2)+(i?` + ${i.toFixed(2)}(new parser instance) `:""),els.resultFull.innerHTML=JSON.stringify(ast,null,"	");const a=prettyAst(ast,{},{variable:'<span class="res-var">',other:'<span class="res-other">',position:'<span class="res-pos">',reset:"</span>",values:"<span>",info:"<span>",error:"<span>",hint:"<span>"});els.resultSimple.innerHTML=a,onKeyboardInput(e,!0)},0)}function onKeyboardInput(e,t=!1){var o;const r=els.input.value;if(t||e.code==="Space"&&e.ctrlKey){(o=e==null?void 0:e.preventDefault)==null||o.call(e);const i=e.target.selectionStart,n=parser.autosuggest(r,ast,i),a=[{type:"Type",isError:"isError",range:"Range"},...n].map(E=>crop`
				<div class="suggestion-entry">
					<div>${E.type}</div>
					${E.isError?`<div>${E.isError}</div>`:"<div></div>"}
					<div>${typeof E.range=="string"?E.range:`[${E.range.start}, ${E.range.end}]`}</div>
				</div>
			`).join(`
`);els.suggestion.innerHTML=a,els.pos.innerHTML=` (${i})`;const l=parser.autocomplete(n,{variables:["variable","variable requires quoting",'variable requires escaping "'],prefixes:["prefix","prefix requires quoting",'prefix requires escaping "'],properties:["property","property requires quoting",'property requires escaping "'],expandedPropertyOperators:["wordOperator"]});console.log(l);const _=[{value:"Value",replacement:"Replacement"},...l].map(E=>{const d=E.replacement??parser.autoreplace(r,E),h=typeof d=="string"?d:`${escapeHtml(d.replacement.slice(0,d.cursor))}</span><span class="cursor">|</span><span>${escapeHtml(d.replacement.slice(d.cursor))}`;return crop`
				<div class="completion-entry">
					<div>${E.value}</div>
					<div><span>${h}</span></div>
				</div>
		`}).join(`
`);els.completion.innerHTML=_}}for(const e of["container","options-raw","options-parsed","input","results","resultSimple","resultFull","resultTime","suggestion","completion","pos"])els[e]=body.querySelector(`.${e}`);els.input.addEventListener("input",onInput);els.input.addEventListener("keyup",onKeyboardInput);els["options-raw"].addEventListener("input",onInput);onInput({target:{selectionStart:0}});function getOpts(){try{let res;return eval(`res = ${els["options-raw"].value}`),res=parseParserOptions(res),els["options-parsed"].innerHTML=JSON.stringify(res,null,"	"),res}catch(e){throw els["options-parsed"].innerHTML=e.message,e}}
